#+Title: Optimization
#+Options: ^:nil toc:1

* Introduction
During compilation and linking, non-functional properties of software
such as running time and executable size may be optimized.  Such
techniques have been extensively researched and implementations can be
found in many of the cornerstones of modern software development
environments such as GCC.

Current techniques almost exclusively rely on operations which may be
formally proven to preserve program semantics.  Using a much looser
test-suite based definition of program behavior we are able to evolve
neutral program variants not reachable through semantic-preserving
operations alone.

Some of these neutral variants may have desirable non-functional
characteristics such as faster running times, reduced energy
consumption or a smaller executable size.  By assigning fitness to
neutral variants based on such non-functional characteristics it
should be possible to optimize software in more radical ways than
possible using existing techniques.  Here we investigate the
application of neutral variants to software optimization.

Modern system emulators allow fine-grained monitoring of aspects of
program execution, such as energy consumption and communication
overhead, which may be difficult to predict a-priori.  We use [[http://groups.csail.mit.edu/carbon/?page_id=111][Graphite]]
to calculate variant fitness in a multi-objective EC system for
software optimization.  We hypothesize a number of benefits to such a
software optimization system, including the following.
- more radical software transformation than possible through semantic
  preserving transformations
- optimization of software properties not readily predictable through
  static analysis
- multi-objective fitness weights allow a natural method for
  developers to specify priorities for non-functional optimization

* Reproduction Instructions
The following instructions may be used to reproduce and expand upon
these results.

** Virtual Machine Setup

1. We will create a Qemu virtual machine and install the Debian 5.0.9
   specifically =debian-5010-i386-netinst.iso= from
   http://cdimage.debian.org/mirror/cdimage/archive/5.0.9/i386/iso-cd/.
   #+begin_src sh
     # create the disk
     qemu-img create -f qcow2 tune.qcow 4G
     # install the operating system
     qemu-system-x86_64 tune.qcow -cdrom debian-5010-i386-netinst.iso -boot d
   #+end_src

2. Walk through the instillation dialog, we'll set the following
   values.
   | hostname            | tune          |
   | version             | stable        |
   | root password       | password      |
   | new user full name  | Francis Bacon |
   | new user login name | bacon         |
   | new user password   | password      |

   As Debian Lenny is no longer supported, You will not be able to
   find a working mirror.  When you are confronted with the warning
   that no working mirror has been found, select the =<Go Back>=
   option, and then continue installing a minimal system with no
   working mirror.  Finish the instillation and Reboot.

3. After booting into the working system, log in as root and add old
   Lenny archive URLs to =/etc/apt/sources.list=.
   #+begin_src sh
     cp /etc/apt/sources.list /etc/apt/sources.list.backup
     echo "deb http://archive.debian.org/debian/ lenny main" >> /etc/apt/sources.list
     echo "deb http://archive.debian.org/debian-security lenny/updates main" >> /etc/apt/sources.list
     apt-get update
   #+end_src

4. Now install the Graphite dependencies,
   #+begin_src sh
     apt-get install build-essential m4
     apt-get install libboost1.35-dev libboost-filesystem1.35-dev libboost-system1.35-dev
     apt-get install git-core
     # and an ssh server so we can ssh into this VM
     apt-get install openssh-server
   #+end_src
   give the =bacon= user =sudo= permissions,
   #+begin_src sh
     apt-get install sudo
     echo "bacon   ALL=(ALL) ALL" >> /etc/sudoers
   #+end_src
   and shutdown the machine.
   #+begin_src sh
     shutdown -h 0
   #+end_src

5. Start up the virtual machine with network access so we can connect
   with ssh -- allowing copy-paste from the local machine, use of a
   normal terminal, and other niceties.
   #+begin_src sh
     qemu-kvm -hda tune.qcow -nographic -cdrom data/debian-5010-amd64-netinst.iso \
         -m 1G -net nic -net user,hostfwd=tcp:127.0.0.1:2222-:22 -daemonize
   #+end_src

6. Log into =tune= as =bacon=.
   #+begin_src sh
     ssh -p 2222 bacon@localhost
   #+end_src
   and install Graphite following these instructions from
   https://github.com/mit-carbon/Graphite/wiki/Getting-Started,
   #+begin_src sh
     wget http://www.cs.virginia.edu/kim/publicity/pin/kits/pin-2.6-27887-gcc.4.0.0-ia32_intel64-linux.tar.gz
     tar xzf pin-2.6-27887-gcc.4.0.0-ia32_intel64-linux.tar.gz
     cd pin
     git clone git://github.com/mit-carbon/Graphite.git graphite
   #+end_src
   and update the =TARGET_ARCH= and =PIN_HOME= variables in =~/graphite/Makefile.config=.
   #+begin_src sh
     cat <<EOF > ~/graphite/Makefile.config
     # Use ia32 for 32-bit, x86_64 for 64-bit
     TARGET_ARCH = x86_64 # <-(may be different depending on your host?)

     # change only if a different (more up-to-date) version of Boost is installed
     BOOST_VERSION = 1_35

     # where Pin is uzipped to
     PIN_HOME = /home/bacon/pin
     EOF
   #+end_src
   run =make= to build Graphite.

7. Confirm that the build was successful by running the following
   which should exit successfully.
   #+begin_src sh
     make ping_pong_app_test CORES=16 PROCS=2
   #+end_src

8. At this point the virtual machine is usable for running
   applications through Graphite and collecting metrics.  If modeling
   power consumption then one more dependency must be installed.
   McPAT is available at http://www.hpl.hp.com/research/mcpat/.  The
   tarball should be downloaded to the virtual machine and unpacked
   into the home directory.
   #+begin_src sh
     cd ~/archives/
     wget http://www.hpl.hp.com/research/mcpat/mcpat0.8_r274.tar.gz
     cd ~
     tar xzf archives/mcpat0.8_r274.tar.g
     sudo apt-get install libc6-dev-i386 lib32stdc++6-dev
     mv mcpat0.8_r274/ mcpat/
     cd mcpat/
     # TODO: something else is required for a successful build
     make
   #+end_src

** Running a Simple Fast Fourier Transform (FFT)
The FFT benchmark has higher memory requirements than the simple
ping-pong test, so for this we'll have to increase the memory of the
VM by passing the =-m 1G= flag to the call to =qemu-kvm=.
#+begin_src sh
  ./src/run-vm tune.qcow 2222
#+end_src

This should run for a while and complete with output that looks like
the following.
: FFT with Blocking Transpose
:    65536 Complex Doubles
:    64 Processors
:    65536 Cache lines
:    16 Byte line size
:    4096 Bytes per page
:
:
:                  PROCESS STATISTICS
:             Computation      Transpose     Transpose
:  Proc          Time            Time        Fraction
:     0          79869664       27878043       0.34904
:
:                  TIMING INFORMATION
: Start time                        : 1333389980838004
: Initialization finish time        : 1333390099558235
: Overall finish time               : 1333390179427899
: Total time with initialization    :        198589895
: Total time without initialization :         79869664
: Overall transpose time            :         27878043
: Overall transpose fraction        :          0.34904

** Evolving a Population of Variants
This experimental setup is held in a git directory available from
http://gitweb.adaptive.cs.unm.edu/optimization.git for anonymous git
access with the following.
: git clone http://gitweb.adaptive.cs.unm.edu/optimization.git

Using the scripts in file:src/host-test.sh and file:src/guest-test.sh,
the experimental harness in file:src/optimize.lisp and the [[http://gitweb.adaptive.cs.unm.edu/software-evolution.git][software
evolution]] framework it is possible to evolve populations of variants
of the original FFT program to optimize for certain execution
properties.  The following instructions describe how to evolve a
population of variant programs using multiple VM back ends for
parallel fitness evaluation.

1. Copy the file:src/guest-test.sh script into the =/home/bacon/bin/=
   on the virtual machine.  Power off the virtual machine before
   performing the next step.
   #+begin_src sh
     scp src/guest-test.sh -P 2222 bacon@localhost:bin/
     ssh -p 2222 root@localhost poweroff
   #+end_src

2. We will use the file:src/limit.c test harness to protect our
   evolutionary process from the sometimes aberrant behavior of the
   test execution shell scripts and the evolved variants which they
   execute.  Compile both host and guest versions of this script and
   place them for use by the host and guest test scripts.
   #+begin_src sh
     # host limit harness
     gcc -o src/limit src/limit.c
     # guest limit harness
     scp src/limit.c -P 2222 bacon@localhost:bin/
     ssh -p 2222 bacon@localhost gcc -o bin/limit bin/limit.c
     ssh -p 2222 root@localhost poweroff
   #+end_src

3. The current version of file:src/host-test.sh assumes that all
   virtual machines are running on =localhost= and that they are
   placed behind different port numbers.  To setup multiple VMs on
   your local machine saving their port numbers to the
   file:src/REMOTES file (as required by file:src/host-test.sh) follow
   the steps in [[#running-overlays][Running overlays]].

4. Since ssh is apparently /very/ sensitive to widely readable public
   keys, be sure to fix access permission for file:data/id_rsa which
   may not be preserved by git.
   #+begin_src sh
     chmod 700 data/id_rsa
   #+end_src

5. Change into the =src/= directory and fire up a Common Lisp
   interpreter (SBCL version 1.0.55 was used to prepare these
   instructions).  Ensure that the [[http://gitweb.adaptive.cs.unm.edu/software-evolution.git][software evolution]] framework is
   installed and load the file:src/optimize.lisp file into your lisp
   session.  To test that things your test scripts, virtual machines,
   and lisp install are all working correctly evaluate the original
   FFT program and ensure that it's fitness is equal to 1.
   #+begin_src lisp
     (require 'software-evolution)
     (in-package 'software-evolution)
     (load "optimize.lisp")
     (unless (neutral-p (evaluate *orig*))
       (error "Something is wrong, debug your script/lisp setup."))
   #+end_src

6. If everything appears to be working as expected, then a population
   of 100 variants can be evolved to minimize execution time by
   running the following.  See file:src/optimize.lisp to change the
   default configuration of things like population size, tournament
   size, and the features optimized for.

** Running overlays
  :PROPERTIES:
  :shebang:  #!/bin/sh
  :CUSTOM_ID: running-overlays
  :END:
Qemu overlays create lightweight disk images based off of a starting
disk image which can be used to store diffs from the original, and to
run multiple instances of an original.

We'll use overlays to parallelize the fitness evaluation in our
genetic algorithm.

To create some number of overlay images run;
#+begin_src sh :tangle src/create-vms
  pushd overlays/
  for i in $(seq 46);do
      j=$(printf "%0.2d" i);
      if [ ! -f "$j.qcow" ];then
          qemu-img create -b ../tune.qcow -f qcow2 "$j.qcow"
      fi
  done
  popd
#+end_src

To run all overlays daemonized;
#+begin_src sh :tangle src/startup-vms
  remotes=""
  pushd overlays/
  for i in $(seq 46);do
      I=$(printf "%0.2d" i);
      ../src/run-vm "$I.qcow" "30$I"
      remotes="$remotes \"30$I\""
  done
  popd
  cat <<EOF > src/REMOTES
  #!/bin/sh
  REMOTES=($remotes)
  EOF
#+end_src

* Experimental Runs
  :PROPERTIES:
  :exports: code
  :eval:     no-export
  :END:

#+Caption: Listing of runs.
#+RESULTS: results-summary
| run                        | state    | git-tag            | machine | results-dir |
|----------------------------+----------+--------------------+---------+-------------|
| First Serial Run           | CANCELED | first-serial-run   | loaf    | first-run   |
| First Parallel Run         | CANCELED | first-parallel-run | real    | first-run   |
| Parallel Runtime Run       | DONE     | pll-runtime-run    | real    | pll-2       |
| Communication Minimization | DONE     | packets-min        | complex | packets-min |
| runtime-2                  | STARTED  | runtime-2          | complex | runtime-2   |

#+name: results-summary
#+begin_src emacs-lisp :exports results
  (let ((fields (list "git-tag" "machine" "results-dir")))
    (append (list (cons "run" (cons "state" fields)) 'hline)
            (remove-if-not
             (lambda (entry) (nth 2 entry))
             (save-restriction
               (org-narrow-to-subtree)
               (cdr
                (org-map-entries
                 (lambda ()
                   (cons (org-get-heading t t)
                         (cons (org-get-todo-state)
                               (mapcar (lambda (field) (org-entry-get (point) field))
                                       fields))))))))))
#+end_src

** CANCELED First Serial Run
   - State "CANCELED"   from "STARTED"    [2012-04-20 Fri 11:30] \\
     accidentally rebooted the machine
   :PROPERTIES:
   :git-tag:  first-serial-run
   :results-dir: first-run
   :dates:    <2012-04-10 Tue>
   :machine:  loaf
   :END:
Running very slowly with only 1 VM running evaluations in the
background.

#+name: first-run-generation-times
#+begin_src lisp :package software-evolution
  (let ((*a-dir* "results/first-run/"))
    (mapcar #'list (mapcar #'float (stat (read-run :steps 18)))))
#+end_src

#+name: first-run-generation-times-plot
#+header: :file data/first-run-generation-times-plot.svg
#+begin_src gnuplot :var data=first-run-generation-times
  set xlabel 'generations'
  set ylabel 'time-wo-init'
  plot data
#+end_src

#+Caption: time-wo-init by generation: too few generations for a trend to develop
[[file:data/first-run-generation-times-plot.svg]]

** CANCELED First Parallel Run
   - State "CANCELED"   from "DONE"       [2012-04-16 Mon 15:08]
   :PROPERTIES:
   :git-tag:  first-parallel-run
   :results-dir: first-run
   :dates:    <2012-04-12 Thu>--<2012-04-13 Fri>
   :machine:  real
   :END:
Failed to collect appropriate statistics, only have running time for
the first generation.

** DONE Parallel Runtime Run
   :PROPERTIES:
   :git-tag:  pll-runtime-run
   :results-dir: pll-2
   :dates:    <2012-04-15 Sun>
   :machine:  real
   :END:
Looks to be working, saving the full population at every generation.

*** Analysis
Analysis code in file:src/pll-2.lisp

#+name: pll-2-runtimes
#+begin_src lisp :package software-evolution
  (mapcar #'list (cdr *times*))
#+end_src

#+name: pll-2-runtimes-plot
#+header: :exports code
#+begin_src gnuplot :var data=pll-2-runtimes :file data/pll-2-runtimes.svg
ylabel 'time-wo-init'
xlabel 'generation'
plot data
#+end_src

#+Caption: Ugh, selection must not have been working, probably a bug...
[[file:data/pll-2-runtimes.svg]]

*** Use the following to restart a failing run
#+begin_src lisp
  (require :software-evolution)
  (in-package :software-evolution)
  (load "optimize.lisp")
  (setf *dir* "../results/pll-2/")
  (setf *pop* (restore "../results/pll-2/biased-pop-126.store"))
  (setf *note-level* 1)
  (advise-thread-pool-size 46)
  (loop for n from 126 to 300 do (note 1 "saving population ~d" n)
       (store *pop* (file-for-run n))
       (note 1 "generating population ~d" (1+ n))
       (setf *pop* (biased-step *pop*)))
#+end_src

** DONE Communication Minimization
   :PROPERTIES:
   :results-dir: packets-min
   :machine:  complex
   :git-tag:  packets-min
   :END:

*** Analysis
Analysis code in file:src/packet-min.lisp

#+name: packets-min-runtimes
#+begin_src lisp :package software-evolution
  (mapcar #'list (cdr *packets*))
#+end_src

#+name: packets-min-runtimes-plot
#+header: :exports code
#+begin_src gnuplot :var data=packets-min-runtimes :file data/packets-min-runtimes.svg
set ylabel 'total-packets-sent'
set xlabel 'generation'
plot data
#+end_src

#+Caption: Ugh, same bug
[[file:data/packets-min-runtimes.svg]]

*** Restarting a stalled run
#+begin_src lisp
  (require :software-evolution)
  (in-package :software-evolution)
  (load "optimize.lisp")
  (setf *dir* "../results/packets-min/")
  (setf *note-level* 1)
  (setf *note-out* (open "../results/packets-min.session"
                         :direction :output
                         :if-exists :append))
  (advise-thread-pool-size 46)
  ;; (biased-walk *orig* :steps 1000 :key #'total-packets-sent)
  (let* ((restart 24)
         (*pop* (restore (file-for-run restart))))
    (loop for n from restart to 1000 do (note 1 "saving population ~d" n)
         (store *pop* (file-for-run n))
         (note 1 "generating population ~d" (1+ n))
         (setf *pop* (biased-step *pop* :key #'total-packets-sent))))
#+end_src

** STARTED runtime-2
   :PROPERTIES:
   :git-tag:  runtime-2
   :results-dir: runtime-2
   :machine:  complex
   :END:

*** running
#+begin_src lisp
  (require :software-evolution)
  (in-package :software-evolution)
  (load "optimize.lisp")
  (setf *dir* "../results/runtime-2/")
  (setf *note-level* 1)
  (advise-thread-pool-size 46)
  (let ((last 1))
    (setf *pop* (restore (file-for-run last)))
    (loop for n from last to 300 do (note 1 "saving population ~d" n)
         (store *pop* (file-for-run n))
         (note 1 "generating population ~d" (1+ n))
         (setf *pop* (biased-step *pop*))))
#+end_src

* COMMENT Notes
** SBCL is going sleeping on the job
Maybe has something to do with script processes dying and never
returning to SBCL, which then hangs the thread and then hangs sbcl
itself.  Could also be a race condition between the threads.

Killing the VM which was hanging ssh connections seems to have started
the SBCL process right back up.  So that is one way forward.  Should
probably start using the limit.c script for these executions.

*** ps auxwwwf from a stalled run
: $ ps auxwwwf
: [...]
: eschulte  3692  0.0  0.0  33940 10124 ?        Ss   Apr11   4:35 SCREEN
: eschulte  4282  0.0  0.0  39700  3772 pts/3    Ss   Apr11   0:00  \_ /usr/bin/zsh
: eschulte  8665  2.6  0.1 8744068 149116 pts/3  Sl+  16:04   8:15  |   \_ sbcl
: eschulte 17732  0.0  0.0      0     0 pts/3    Z    19:01   0:00  |       \_ [host-test.sh] <defunct>
: eschulte 17739  0.0  0.0      0     0 pts/3    Z    19:01   0:00  |       \_ [host-test.sh] <defunct>
: eschulte  9033  0.0  0.0  45688  9700 pts/1    Ss+  Apr11   0:01  \_ /usr/bin/zsh
: eschulte 23988  0.0  0.0  39816  3892 pts/2    Ss+  Apr12   0:01  \_ /usr/bin/zsh
: eschulte  2472  0.0  0.0  39684  3684 pts/33   Ss   12:35   0:00  \_ /usr/bin/zsh
: [...]

*** logging output from a stalled run
: SOFTWARE-EVOLUTION(12): (biased-walk *orig*)
:
: 2012.04.15.23.22.40: saving population 0
: 2012.04.15.23.22.40: generating population 1
: 2012.04.15.23.22.40: generating 46
: 2012.04.15.23.32.46: keeping the fit
: 2012.04.15.23.32.46: (length results) ;; => 47
: 2012.04.15.23.32.46: generating 46
: 2012.04.15.23.42.57: keeping the fit
: 2012.04.15.23.42.57: (length results) ;; => 94
: 2012.04.15.23.42.57: generating 18
: 2012.04.15.23.48.04: keeping the fit
: 2012.04.15.23.48.04: (length results) ;; => 113
: 2012.04.15.23.48.04: saving population 1
: 2012.04.15.23.48.05: generating population 2
: 2012.04.15.23.48.05: generating 46
: 2012.04.15.23.58.14: keeping the fit
: 2012.04.15.23.58.14: (length results) ;; => 47
: 2012.04.15.23.58.14: generating 46
: 2012.04.16.00.08.23: keeping the fit
: 2012.04.16.00.08.23: (length results) ;; => 94
: 2012.04.16.00.08.23: generating 18
: 2012.04.16.00.13.32: keeping the fit
: 2012.04.16.00.13.32: (length results) ;; => 113
: 2012.04.16.00.13.32: saving population 2
: 2012.04.16.00.13.32: generating population 3
: 2012.04.16.00.13.32: generating 46
: 2012.04.16.00.23.49: keeping the fit
: 2012.04.16.00.23.49: (length results) ;; => 47
: 2012.04.16.00.23.49: generating 46
: 2012.04.16.00.34.09: keeping the fit
: 2012.04.16.00.34.09: (length results) ;; => 94
: 2012.04.16.00.34.09: generating 18
: 2012.04.16.00.39.17: keeping the fit
: 2012.04.16.00.39.17: (length results) ;; => 113
: 2012.04.16.00.39.17: saving population 3
: 2012.04.16.00.39.17: generating population 4
: 2012.04.16.00.39.17: generating 46
: 2012.04.16.00.49.24: keeping the fit
: 2012.04.16.00.49.24: (length results) ;; => 47
: 2012.04.16.00.49.24: generating 46
: 2012.04.16.00.59.41: keeping the fit
: 2012.04.16.00.59.41: (length results) ;; => 94
: 2012.04.16.00.59.41: generating 18
: 2012.04.16.01.04.51: keeping the fit
: 2012.04.16.01.04.51: (length results) ;; => 113
: 2012.04.16.01.04.51: saving population 4
: 2012.04.16.01.04.52: generating population 5
: 2012.04.16.01.04.52: generating 46
: 2012.04.16.01.15.09: keeping the fit
: 2012.04.16.01.15.09: (length results) ;; => 47
: 2012.04.16.01.15.09: generating 46
: 2012.04.16.01.25.18: keeping the fit
: 2012.04.16.01.25.18: (length results) ;; => 94
: 2012.04.16.01.25.18: generating 18
: 2012.04.16.01.30.28: keeping the fit
: 2012.04.16.01.30.28: (length results) ;; => 113
: 2012.04.16.01.30.28: saving population 5
: 2012.04.16.01.30.28: generating population 6
: 2012.04.16.01.30.28: generating 46
: 2012.04.16.01.40.43: keeping the fit
: 2012.04.16.01.40.43: (length results) ;; => 47
: 2012.04.16.01.40.43: generating 46
:

*** tried wrapping in trivial timeout
In case the shell scripts were hanging, but to no effect.

** configuration and output
Configuration is controlled in =carbon_sim.cfg= in the base of the
graphite directory.

Detailed simulator output information is written to =sim.out= in the
=output_files= directory under graphite.

Configurations notes
- more complex core model would have variable instruction costs
- more complex network (hop by hop)
- power_modeling to true
- enable_models_at_startup set to false
- maybe try different synchronization schemes

Date file notes
- "Tile" is a Core
- network model 2 is the actual communication of the process
  (this is what matters)

** running times by VM memory
Running =time ./bin/guest-test.s=.

- with =-m 1024=.
  : real    4m20.468s
  : user    2m27.185s
  : sys     1m52.055s

- with =-m 2048=
  : real    4m19.885s
  : user    2m25.457s
  : sys     1m53.167s

** successfully running evolutionary steps
#+begin_src slime-repl
  SOFTWARE-EVOLUTION> (setf results '(#<PLL-ASM {1008347463}> #<PLL-ASM {1007F17463}>))

  ; in: SETF RESULTS
  ;     (SETF SOFTWARE-EVOLUTION::RESULTS
  ;             '(#<SOFTWARE-EVOLUTION::PLL-ASM {1008347463}>
  ;               #<SOFTWARE-EVOLUTION::PLL-ASM {1007F17463}>))
  ; ==>
  ;   (SETQ SOFTWARE-EVOLUTION::RESULTS
  ;           '(#<SOFTWARE-EVOLUTION::PLL-ASM {1008347463}>
  ;             #<SOFTWARE-EVOLUTION::PLL-ASM {1007F17463}>))
  ;
  ; caught WARNING:
  ;   undefined variable: RESULTS
  ;
  ; compilation unit finished
  ;   Undefined variable:
  ;     RESULTS
  ;   caught 1 WARNING condition
  (#<PLL-ASM {1008347463}> #<PLL-ASM {1007F17463}>)
  SOFTWARE-EVOLUTION> (equal-it (genome (first results)) (genome (second results)))
  STYLE-WARNING: redefining SOFTWARE-EVOLUTION::STATS in DEFUN
  NIL
  SOFTWARE-EVOLUTION> (mapcar #'stats results)
  (((TIME-WO-INIT . 103187924) (HISTORY (:SWAP 3561 2147)))
   ((TIME-WO-INIT . 101699638) (HISTORY (:INSERT 1600 2344))))
#+end_src

** Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq opt-dir (file-name-directory (or load-file-name buffer-file-name)))
  (setq opt-server "moons.cs.unm.edu")
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("opt-html"
                 :base-directory ,opt-dir
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/opt/"
                                                opt-server)
                 :publishing-function org-publish-org-to-html
                 :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    /* pre{display:table-cell;background:#232323; color:#e6e1dc;} */
    #content{max-width:1000px;margin:auto;} body{ font-size:small; } table{ font-size:small; }
    .outline-text-2{margin-left:2em;}.outline-text-3{margin-left:3em;}
    .title  { text-align: center; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #postamble { color: gray; padding-top: 2em; font-size: 0.75em; }
    /*]]>*/-->
  </style>"))
  (add-to-list 'org-publish-project-alist
               `("opt-src"
                 :base-directory ,(expand-file-name "src" opt-dir)
                 :base-extension "txt\\|sh\\|lisp\\|html"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/opt/src/"
                                                opt-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("opt-data"
                 :base-directory ,(expand-file-name "data" opt-dir)
                 :base-extension "txt\\|sh\\|lisp\\|html\\|s\\|svg"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/opt/data/"
                                                opt-server)
                 :publishing-function org-publish-attachment))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("opt" :components ("opt-html" "opt-src" "opt-data")))
#+end_src
