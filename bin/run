#!/bin/bash
#
# Usage: run BENCHMARK EXECUTABLE [OPTIONS...]
#  run a version of a benchmark program
#
# Options:
#  -l,--limit ----- limit script for sandboxing
#  -p,--perf ------ collect performance counters
#  -c,--counters -- comma separated list of perf counters
#  -w,--wattsup --- collect watts-up data during execution
#  -r,--repeat N -- repeat the execution N times
#  -R,--raw ------- print raw output
#  -s,--size ------ input size test,tiny,small,medium,large
#  -d,--debug ----- print commands before running them
#
# Benchmark should be one of
#  blackscholes
#  bodytrack
#  facesim
#  ferret
#  fluidanimate
#  freqmine
#  raytrace
#  swaptions
#  vips
#  x264
#
. $(dirname $0)/common

## Parse Options
if [ $# -lt 2 ];then help; fi
BENCHMARK="$1"
case $BENCHMARK in
    blackscholes) SIZE=large;;
    bodytrack)    SIZE=large;;
    fluidanimate) SIZE=large;;
    freqmine)     SIZE=medium;;
    swaptions)    SIZE=medium;;
    vips)         SIZE=medium;;
    bzip2)        SIZE=large;;
    h264ref)      SIZE=large;;
    *) error "no test implemented for '$BENCHMARK'";;
esac
EXECUTABLE="$2"
LIMIT="./bin/no-stack-limit"
PERF=""
COUNTERS=""
WATTSUP=""
REPEAT=""
RAW=""
DEBUG=""
EXIT=""
ERROR=""
OUT=$(mktemp)
eval set -- \
    $(getopt -o l:pc:wr:rs:d \
    -l limit:,perf,counters:,wattsup,repeat:,raw,size:,debug \
    -- "$@" || help;)
while [ $# -gt 0 ];do
    case $1 in
        -l|--limit) LIMIT="$2"; shift;;
        -p|--perf)  PERF="yes";;
        -r|--repeat) REPEAT="$2"; shift;;
        -c|--counters) PERF="yes"; COUNTERS="$2"; shift;;
        -w|--wattsup) WATTSUP="yes";;
        -R|--raw) RAW="yes";;
        -s|--size) SIZE="$2"; shift;;
        -d|--debug) DEBUG="yes";;
        (--) shift; break;;
        (-*) error "unrecognized option $1";;
        (*)  break;;
    esac
    shift
done
if [ ! -z $RAW ] && [ ! -z $PERF ];then
    error "can't print RAW and PERF results simultaneously"
fi


if [ -z $COUNTER ];then
  if grep -q Intel /proc/cpuinfo; then
    COUNTERS="task-clock,cycles,instructions,r532010,r538010,cache-references,cache-misses"
  elif grep -q AMD /proc/cpuinfo; then
    COUNTERS="task-clock,cycles,instructions,r533f00,cache-references,cache-misses"
  fi
fi

PREFIX="$LIMIT"
if [ ! -z $WATTSUP ];then
    error "haven't implemented watts-up support."
fi
if [ -z $PERF ];then
    # maybe print out RAW and clean up OUT
    function exit_hook (){
        if [ -z $RAW ];then
            echo "$EXIT,exit"
            echo "$ERROR,error"
        else
            cat $OUT
        fi
        rm -f $OUT; }
else
    # perf prefix to the command
    PERF_OUT=$(mktemp)
    PREFIX+=" perf stat -e $COUNTERS -o $PERF_OUT"
    if [ ! -z "$REPEAT" ];then PREFIX+=" -r $REPEAT"; fi
    # handle perf output on exit
    function exit_hook (){
        echo "$EXIT,exit"
        echo "$ERROR,error"
        cat $PERF_OUT \
            |grep "[0-9,]\+ [a-z]\+" \
            |sed 's/^ *//;s/,//g;s/ \([^ ]\+\).*$/,\1/';
        rm -f $PERF_OUT;
        rm -f $OUT; }
fi
trap exit_hook EXIT

INPUT="$BASE/benchmarks/$BENCHMARK/$BENCHMARK.input"
OUTPUT="$BASE/benchmarks/$BENCHMARK/$BENCHMARK.output"

AWK_CMD=''
AWK_CMD+='function abs(x){return ((x < 0.0) ? -x : x)}'
AWK_CMD+='BEGIN{ diff=0; }'
AWK_CMD+='{ diff+=abs($1-$2); }'
AWK_CMD+='END { print diff }'
num_diff(){ # diff of aggregate numerical closeness
    paste <(awk '{print $1}' $1) <(awk '{print $1}' $2)|awk "$AWK_CMD"; }

run(){ # run, first argument picks an output stream to return
    local out=$1; shift;
    if [ ! -z $DEBUG ];then echo "$PREFIX $@" >&2; fi
    # possibly to multiple runs
    if [ -z $PERF ] && [ ! -z $REPEAT ];then
        for i in $(seq $(($REPEAT - 1)));do
            $PREFIX $@ 1>/dev/null 2>/dev/null
        done
    fi
    # then do the run that counts
    if [ $out -eq 1 ];then
        $PREFIX $@ 2>/dev/null
    elif [ $out -eq 2 ];then
        $PREFIX $@ 3>&1 1>/dev/null 2>&3
    else
        $PREFIX $@ 1>/dev/null 2>/dev/null
    fi; }

freqclean(){
    sed 's/[()]//g'|awk '{all=0; for(i=1; i<=NF; i++){all+=$i}; print all}'; }

case $BENCHMARK in
    blackscholes)
        run 0 $EXECUTABLE 1 "$INPUT" $OUT
        EXIT=$?
        if [ -z $RAW ];then
            ERROR=$(num_diff $OUT $OUTPUT);
        fi
        ;;
    bodytrack)
        case $SIZE in
            test)   run 0 $EXECUTABLE $INPUT 4 1 5    1 0 1;;
            tiny)   run 0 $EXECUTABLE $INPUT 4 1 100  3 0 1;;
            small)  run 0 $EXECUTABLE $INPUT 4 1 1000 5 0 1;;
            medium) run 0 $EXECUTABLE $INPUT 4 2 2000 5 0 1;;
            large)  run 0 $EXECUTABLE $INPUT 4 4 4000 5 0 1;;
        esac
        EXIT=$?
        cat $INPUT/Result000*.bmp > $OUT
        if diff $OUT $OUTPUT;then
            ERROR=0;
        else
            ERROR=1;
        fi
        ;;
    fluidanimate)
        case $SIZE in
            test)   run 0 $EXECUTABLE 1 1 "$INPUT" $OUT;;
            tiny)   run 0 $EXECUTABLE 1 3 "$INPUT" $OUT;;
            small|medium|large) run 0 $EXECUTABLE 1 5 "$INPUT" $OUT;;
        esac
        EXIT=$?
        if diff $OUT $OUTPUT;then
            ERROR=0;
        else
            ERROR=1;
        fi
        ;;
    freqmine)
        case $SIZE in
            test)   run 0 $EXECUTABLE "$INPUT" 1   $OUT;;
            tiny)   run 0 $EXECUTABLE "$INPUT" 3   $OUT;;
            small)  run 0 $EXECUTABLE "$INPUT" 220 $OUT;;
            medium) run 0 $EXECUTABLE "$INPUT" 410 $OUT;;
            large)  run 0 $EXECUTABLE "$INPUT" 790 $OUT;;
        esac
        EXIT=$?
        if [ -z $RAW ];then
            ERROR=$(num_diff <(cat $OUT|freqclean) <(cat $OUTPUT|freqclean));
        fi
        ;;
    swaptions)
        case $SIZE in
            test)  run 2 $EXECUTABLE -ns 1  -sm 5     -nt 1 > $OUT;;
            tiny)  run 2 $EXECUTABLE -ns 3  -sm 50    -nt 1 > $OUT;;
            small) run 2 $EXECUTABLE -ns 16 -sm 10000 -nt 1 > $OUT;;
            medium)run 2 $EXECUTABLE -ns 32 -sm 20000 -nt 1 > $OUT;;
            large) run 2 $EXECUTABLE -ns 64 -sm 40000 -nt 1 > $OUT;;
        esac
        EXIT=$?
        left=$(awk '{print $4}' $OUT)
        right=$(awk '{print $4}' $OUTPUT)
        if [ -z $RAW ];then
            ERROR=$(paste <(echo "$left") <(echo "$right")|awk "$AWK_CMD")
        fi
        ;;
    vips)
        tmp=$(mktemp /tmp/tmp.XXXXXXXX.v)
        run 0 $EXECUTABLE im_benchmark "$INPUT" $tmp
        EXIT=$?
        mv $tmp $OUT
        if diff \
            <(grep --binary-file=text -v im_benchmark $OUT) \
            <(grep --binary-file=text -v im_benchmark $OUTPUT);then
            ERROR=0;
        else
            ERROR=1;
        fi
        ;;

    # Instruction for running SPEC programs
    #
    # 13 (run it), it tells you to use "specinvoke" but the fine print
    # about a cross-compiled environment mentions how to find the
    # actual commands.
    #
    # http://www.spec.org/cpu2006/Docs/runspec-avoidance.html
    #
    # Unfortunately, spec actually uses C programs which are linked
    # with their benchmarks as their test drivers, so we might not be
    # able to simply re-use their stuff.
    # 
    bzip2)
        tmp=$(mktemp)
        cp "$INPUT" $tmp
        run 1 $EXECUTABLE -c $tmp > $OUT
        EXIT=$?
        ERROR=0
        rm -f $tpm
        # compare compressed size to original compressed file
        if [ $(cat $OUT|wc -c) -gt $(cat $OUTPUT|wc -c) ];then
            ERROR=$(($ERROR + 1))
        fi
        # then un-compress and compare to the original
        if ! diff -q "$INPUT" <(bunzip2 -c $OUT);then
            ERROR=$(($ERROR + 10))
        fi
        ;;
    h264ref)
        case $SIZE in
            test)   FRAMES=1;;
            tiny)   FRAMES=2;;
            small)  FRAMES=4;;
            medium) FRAMES=6;;
            large)  FRAMES=8;;
        esac
        run 0 $EXECUTABLE -d "${INPUT%.input}.cfg" \
            -p FramesToBeEncoded=$FRAMES \
            -p InputFile="$INPUT" \
            -p OutputFile="$OUT"
        EXIT=$?
        if ! diff -q $OUTPUT $OUT;then
            ERROR=10
        else
            ERROR=0
        fi
        ;;
    *) error "no test implemented for '$BENCHMARK'";;
esac
