#!/bin/bash
#
# Usage: mgmt ACTION BENCHMARK [OPTIONS...]
#  manage benchmark programs
#
# Actions:
#  clean ----------- remove the specified benchmark
#  unpack ---------- download or copy the benchmark source
#  compile --------- compile the benchmark to assembly
#  link ------------ link the assembly benchmark to an executable
#  input ----------- generate test input for benchmark
#  output ---------- generate correct test output for benchmark
#
# Options:
#  -f,--flags ------ either `all' or `min'
#  -l,--llvm ------- compile to and link from LLVM IR (not ASM)
#
. $(dirname $0)/common

## Parse Options
if [ $# -lt 2 ];then help; fi
ACTION="$1"
BENCHMARK="$2"
FLAGS="min"
LLVM=""
eval set -- $(getopt -o f:l -l flags:,llvm -- "$@" || help;)
while [ $# -gt 0 ];do
    case $1 in
        -f|--flags) FLAGS="$2"; shift;;
        -l|--llvm)  error "the 'llvm' option is not implemented.";;
        (--) shift; break;;
        (-*) error "unrecognized option $1";;
        (*)  break;;
    esac
    shift
done

## PARSEC applications
declare -a PARSEC_APPS
PARSEC_APPS+=(blackscholes)
PARSEC_APPS+=(bodytrack)
PARSEC_APPS+=(facesim)
PARSEC_APPS+=(ferret)
PARSEC_APPS+=(fluidanimate)
PARSEC_APPS+=(freqmine)
PARSEC_APPS+=(raytrace)
PARSEC_APPS+=(swaptions)
PARSEC_APPS+=(vips)
PARSEC_APPS+=(x264)

## Compilation Flags
PARSEC_BASE_FLAGS_ALL="-O3 -g -funroll-loops -fprefetch-loop-arrays "
PARSEC_BASE_FLAGS_ALL+="-fpermissive -fno-exceptions -static-libgcc "
PARSEC_BASE_FLAGS_ALL+="-Wl,--hash-style=both,--as-needed "

BLACKSCHOLES_FLAGS_ALL="$PARSEC_BASE_FLAGS_ALL"
BLACKSCHOLES_FLAGS_ALL+="-pthread -DENABLE_THREADS "
BLACKSCHOLES_FLAGS_ALL+="-DNCO=4"

BLACKSCHOLES_FLAGS_MIN="-DNCO=4"

FLUID_FLAGS_ALL="$PARSEC_BASE_FLAGS_ALL"
FLUID_FLAGS_ALL+="-Wno-invalid-offsetof "
FLUID_FLAGS_ALL+="-pthread -D_GNU_SOURCE -D__XOPEN_SOURCE=600"

FLUID_FLAGS_MIN="-Wno-invalid-offsetof"

## Functions
unpack(){ # dispatch depending on benchmark suite
    if echo "${PARSEC_APPS[@]}"|grep -q $1;then
        parsec_unpack $1;
    elif echo "${SPEC_APPS[@]}"|grep -q $1;then
        spec_unpack $1;
    else
        error "benchmark '$1' is not known"
    fi; }

parsec_unpack(){
    local bench=$1;
    local bench_dir="$BASE/benchmarks/$bench";
    if [ -d "$bench_dir" ];then
        msg "$bench/ exists"
    else
        mkdir -p "$bench_dir"
        cp -R "$BASE"/benchmarks/parsec-3.0/pkgs/apps/$bench/src/* "$bench_dir"
        msg "$bench/ created"
    fi; }

spec_unpack(){
    error "'spec_unpack' is not yet implemented"; }

not_implemented(){
    error "$1 compilation not yet implemented"; }

compile(){
    local bench=$1;
    local bench_dir="$BASE/benchmarks/$bench";

    if [ -f "$bench_dir/$bench.s" ];then
        msg "$bench/$bench.s exists"
    else
        pushd "$bench_dir">/dev/null
        case $bench in
            blackscholes)
                case $FLAGS in
                    min) FLAGS="$BLACKSCHOLES_FLAGS_ALL";;
                    all) FLAGS="$BLACKSCHOLES_FLAGS_MIN";;
                esac
                m4 ./c.m4.pthreads blackscholes.c > blackscholes.m4.cpp
                g++ $FLAGS blackscholes.m4.cpp -S -o blackscholes.s
                ;;
            bodytrack) not_implemented $bench ;;
            facesim) not_implemented $bench ;;
            ferret)
                # This depends on the gsl library, to build gsl from
                # parsec, the last 9 lines of gsl/doc/bspline.texi
                # must be removed.
                not_implemented $bench ;;
            fluidanimate)
                cat pthreads.cpp >  all.cpp
                cat cellpool.cpp >> all.cpp
                cat parsec_barrier.cpp >> all.cpp
                case $FLAGS in
                    min) FLAGS="$FLUID_FLAGS_ALL";;
                    all) FLAGS="$FLUID_FLAGS_MIN";;
                esac
                g++ $FLAGS -S all.cpp -o ${bench}.s||err "compilation failed"
                ;;
            freqmine)
                case $FLAGS in
                    min) FLAGS="-Wno-deprecated";;
                    all) FLAGS="$PARSEC_BASE_FLAGS_ALL -Wno-deprecated";;
                esac
                cat <<EOF > all.cpp
#include "common.h"
static int omp_get_max_threads() {return 1;}
EOF
                cat *.cpp \
                    |grep -v "common.h" \
                    |grep -v "static int omp_get_max_threads" >> all.cpp
                g++ $FLAGS -S all.cpp -o ${bench}.s||err "compilation failed"
                ;;
            raytrace)
                # To build this add '#include <unistd.h>' to the top
                # of raytrace/src/RTTL/common/MapOptions.hxx.
                not_implemented $bench ;;
            swaptions)
                SWAP_FLAGS="-pthread  -DENABLE_THREADS"
                case $FLAGS in
                    min) FLAGS="$SWAP_FLAGS";;
                    all) FLAGS="$PARSEC_BASE_FLAGS_ALL $SWAP_FLAGS";;
                esac
                cat *.c* > all.cpp
                g++ $FLAGS -S all.cpp -o ${bench}.s||err "compilation failed"
                ;;
            vips) not_implemented $bench ;;
            x264) not_implemented $bench ;;
        esac
        popd>/dev/null
        msg "$bench/$bench.s created"
    fi; }

link(){
    local bench=$1;
    local bench_dir="$BASE/benchmarks/$bench";

    if [ -f "$bench_dir/$bench" ];then
        msg "$bench/$bench exists"
    else
        pushd "$bench_dir">/dev/null
        case $bench in
            blackscholes)
                case $FLAGS in
                    min) FLAGS="$BLACKSCHOLES_FLAGS_ALL";;
                    all) FLAGS="$BLACKSCHOLES_FLAGS_MIN";;
                esac
                g++ $FLAGS ${bench}.s -o $bench||err "linking failed"
                ;;
            fluidanimate)
                case $FLAGS in
                    min) FLAGS="$FLUID_FLAGS_ALL";;
                    all) FLAGS="$FLUID_FLAGS_MIN";;
                esac
                g++ $FLAGS ${bench}.s -o $bench||err "linking failed"
                ;;
            freqmine)
                case $FLAGS in
                    min) FLAGS="-Wno-deprecated";;
                    all) FLAGS="$PARSEC_BASE_FLAGS_ALL -Wno-deprecated";;
                esac
                g++ $FLAGS ${bench}.s -o $bench||err "compilation failed"
                ;;
            swaptions)
                SWAP_FLAGS="-pthread  -DENABLE_THREADS"
                case $FLAGS in
                    min) FLAGS="$SWAP_FLAGS";;
                    all) FLAGS="$PARSEC_BASE_FLAGS_ALL $SWAP_FLAGS";;
                esac
                g++ $FLAGS ${bench}.s -o $bench||err "compilation failed"
                ;;
            *) error "linking not implemented for $bench"
        esac
        popd>/dev/null
        msg "$bench/$bench created"
    fi; }

input(){
    local bench=$1;
    local target=$bench.input;
    local bench_dir="$BASE/benchmarks/$bench";
    local parsec_dir="$BASE/benchmarks/parsec-3.0/pkgs/apps/$bench";
    pushd "$bench_dir">/dev/null

    if [ -f "$bench_dir/$target" ];then
        msg "$bench/$target exists"
    else
        case $BENCHMARK in
            blackscholes)
                tar xf ${parsec_dir}/inputs/input_simlarge.tar
                mv in_64K.txt $target;;
            fluidanimate)
                tar xf ${parsec_dir}/inputs/input_simlarge.tar
                mv in_300K.fluid $target;;
            freqmine)
                tar xf ${parsec_dir}/inputs/input_simmedium.tar
                mv kosarak_500k.dat $target;;
            swaptions)
                msg "no input needed for $bench"
                return 0;;
            *) error "input not implemented for $bench";;
        esac;
        popd>/dev/null
        msg "$bench/$target created";
    fi; }

output(){
    local bench=$1;
    local target=$bench.output;
    local bench_dir="$BASE/benchmarks/$bench";
    pushd "$bench_dir">/dev/null

    if [ -f "$bench_dir/$target" ];then
        msg "$bench/$target exists"
    else
        input $bench;
        case $BENCHMARK in
            blackscholes)
                ./$bench 1 $bench.input $target;;
            fluidanimate)
                ./$bench 1 5 $bench.input $target;;
            freqmine)
                ./$bench $bench.input 790 $target;;
            swaptions)
                ./$bench -ns 32 -sm 20000 -nt 1 2> $target;;
            *) error "output not implemented for $bench";;
        esac;
        popd>/dev/null
        msg "$bench/$target created";
    fi; }

## Ensure the requisite benchmark suite is installed
if echo "${PARSEC_APPS[@]}"|grep -q $BENCHMARK;then
    parsec_dir="$BASE/benchmarks/parsec-3.0"
    parsec_tar="$BASE/etc/data/parsec-3.0.tar.gz"
    if [ ! -d "$parsec_dir" ];then
        if [ ! -f "$parsec_tar" ];then
            msg "downloading PARSEC"
            wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz \
                -O "$BASE/etc/data/parsec-3.0.tar.gz"
        fi
        msg "unpacking PARSEC"
        tar xzf "$BASE/etc/data/parsec-3.0.tar.gz" -C "$BASE/benchmarks"
    fi
elif echo "${SPEC_APPS[@]}"|grep -q $1;then
    error "spec must be installed in $BASE/benchmarks/spec/"
fi

## Run the actions
case $ACTION in
    clean) rm -rf "$BASE/benchmarks/$BENCHMARK"
        msg "$BENCHMARK/ removed"
        exit 0;;

    input) unpack $BENCHMARK && input $BENCHMARK;;

    unpack|compile|link|output)
        
        unpack $BENCHMARK
        [[ $ACTION == "unpack" ]] && exit 0;

        compile $BENCHMARK
        [[ $ACTION == "compile" ]] && exit 0;

        link $BENCHMARK
        [[ $ACTION == "link" ]] && exit 0;

        output $BENCHMARK
        [[ $ACTION == "output" ]] && exit 0;
        ;;

    *) error "'$ACTION' is not a valid action\n";;
esac
