#!/usr/bin/sbcl --script
;; -*- mode: lisp -*-
;;
;; Usage: optimize program test [OPTIONS...]
;;  Optimize a benchmark program against a test script
;;
;; Options:
;;  -l,--linker LINKER ---- linker to use
;;  -t,--threads NUM ------ number of threads
;;  -e,--max-evals NUM ---- max number of fitness evals
;;  -p,--pop-size NUM ----- population size
;;  -w,--work-dir DIR ----- use an sh-runner/work directory
;;  -E,--max-error NUM ---- maximum allowed error
;;  -m,--model NAME ------- model name
;;  -P,--period NUM ------- period (in evals) of checkpoints
;;                          (default max-evals/1024)
;;  -v,--verbose NUM ------ verbosity level 0-4 (default 1)
;;  -r,--res-dir DIR ------ save results to dir
;;                          (default program.opt/)
;;
;; Notes:
;;  If you require more working memory on your system,
;;  build sbcl with the following.
;;
;;    ./make.sh --dynamic-space-size=SIZE
;;
;; TODO:
;; - switch this from a shell script to a compiled
;;   application (buildapp) for faster startup
;;

;;; Code:
(let ((*error-output* (make-broadcast-stream)))
  (load (merge-pathnames ".sbclrc" (user-homedir-pathname))))
(load "bin/common.lisp")
(in-package :optimize)


;;; Help info, argument processing and variables initialization
(defvar *help*
  (with-open-file (in "bin/optimize")
    (read-line in) (read-line in) (read-line in) ;; discard first few lines
    (mapconcat (lambda (it) (subseq it (min (length it) 3)))
               (loop :for line = (read-line in nil)
                  :while (and line
                              (>= (length line) 2)
                              (string= (subseq line 0 2) ";;"))
                  :collect line) (format nil "~%"))))
(when (< (length sb-ext:*posix-argv*) 2)
  (throw-error "insufficient number of arguments~%~%~a" *help*))

(when (or (string= (subseq (car sb-ext:*posix-argv*) 0 2) "-h")
          (string= (subseq (car sb-ext:*posix-argv*) 0 3) "--h"))
  (throw-error "~a~%" *help*))

(setf *path* (arg-pop))
(setf *script* (arg-pop))
(setf *orig* (from-file (make-instance 'asm-perf) *path*))
(setf *res-dir* (append (pathname-directory *path*)
                        (list (concatenate 'string
                                (pathname-name *path*) ".opt"))))

(getopts
 ("-l" "--linker"    (setf (linker *orig*) (arg-pop)))
 ("-t" "--threads"   (setf *threads* (parse-integer (arg-pop))))
 ("-e" "--max-evals" (setf *evals* (parse-integer (arg-pop))))
 ("-w" "--work-dir"  (setf *work-dir* (arg-pop)))
 ("-E" "--max-err"   (setf *max-err* (read-from-string (arg-pop))))
 ("-p" "--pop-size"  (setf *max-population-size* (parse-integer (arg-pop))))
 ("-m" "--model"     (setf *model* (intern (string-upcase (arg-pop)))))
 ("-P" "--period"    (setf *period* (parse-integer (arg-pop))))
 ("-v" "--verb"      (let ((lvl (parse-integer (arg-pop))))
                       (when (= lvl 4) (setf *shell-debug* t))
                       (setf *note-level* lvl)))
 ("-r" "--res-dir"   (setf *res-dir*
                           (let ((dir (arg-pop)))
                             (pathname-directory
                              (if (string= (subseq dir (1- (length dir))) "/")
                                  dir
                                  (concatenate 'string dir "/")))))))

(unless *period* (setf *period* (ceiling (/ *evals* (expt 2 10)))))

(unless (ensure-directories-exist *res-dir*)
  (throw-error "Unable to make result directory `~a'.~%" *res-dir*))


;;; Run optimization
(note 1 "Evaluating the original.")
(setf (fitness *orig*) (test *orig*))

;; sanity check
(if (< (fitness *orig*) infinity)
    (note 2 "Original program has fitness ~a" (fitness *orig*))
    (throw-error "Original program has no fitness!"))

;; populate population
(note 1 "Building the Population")
(setf *population*
      (loop :for n :below *max-population-size* :collect (copy *orig*)))

;; run optimization
(note 1 "Kicking off ~a optimization threads" *threads*)

(defun optimize ()
  (evolve #'test :max-evals *evals* :period *period* :period-func #'checkpoint))

(let (threads)
  ;; kick off optimization threads
  (loop :for n :below *threads* :do
     (push (sb-thread:make-thread #'optimize) threads))
  ;; wait for all threads to return
  (mapc #'sb-thread:join-thread threads))

(note 1 "done after ~a fitness evaluations" *fitness-evals*)
