#!/usr/bin/sbcl --script
;; -*- mode: lisp -*-
;;
;; Usage: optimize program test [OPTIONS...]
;;  Optimize a benchmark program against a test script
;;
;; Options:
;;  -l,--linker LINKER ---- linker to use
;;  -t,--threads NUM ------ number of threads
;;  -e,--max-evals NUM ---- max number of fitness evals
;;  -w,--work-dir DIR ----- alternate work directory
;;  -E,--max-error NUM ---- maximum allowed error
;;  -m,--model NAME ------- model name
;;  -v,--verbose NUM ------ verbosity level 0-4 (default 1)
;;
;; Notes:
;;  If you require more working memory on your system,
;;  build sbcl with the following.
;;
;;    ./make.sh --dynamic-space-size=SIZE
;;
;; TODO:
;; - switch this from a shell script to a compiled
;;   application (buildapp) for faster startup
;;

;;; Code:
(let ((*error-output* (make-broadcast-stream)))
  (load (merge-pathnames ".sbclrc" (user-homedir-pathname))))
(load "bin/common.lisp")
(in-package :optimize)


;;; Help info, argument processing and variables initialization
(defvar *help*
  (with-open-file (in "bin/optimize")
    (read-line in) (read-line in) (read-line in) ;; discard first few lines
    (mapconcat (lambda (it) (subseq it (min (length it) 3)))
               (loop :for line = (read-line in nil)
                  :while (and line
                              (>= (length line) 2)
                              (string= (subseq line 0 2) ";;"))
                  :collect line) (format nil "~%"))))
(when (< (length sb-ext:*posix-argv*) 2)
  (throw-error "insufficient number of arguments~%~%~a" *help*))

(when (or (string= (subseq (car sb-ext:*posix-argv*) 0 2) "-h")
          (string= (subseq (car sb-ext:*posix-argv*) 0 3) "--h"))
  (throw-error "~a~%" *help*))

(setf *path*   (arg-pop))
(setf *script* (arg-pop))
(setf *orig*   (from-file (make-instance 'asm-perf) *path*))

(getopts
 ("-l" "--linker"    (setf (linker *orig*) (arg-pop)))
 ("-t" "--threads"   (setf *threads* (parse-integer (arg-pop))))
 ("-e" "--max-evals" (setf *evals* (parse-integer (arg-pop))))
 ("-w" "--work-dir"  (setf *work-dir* (arg-pop)))
 ("-E" "--max-err"   (setf *max-err* (read-from-string (arg-pop))))
 ("-p" "--pop-size"  (setf *max-population-size* (parse-integer (arg-pop))))
 ("-m" "--model"     (setf *model* (intern (string-upcase (arg-pop)))))
 ("-v" "--verb"      (let ((lvl (parse-integer (arg-pop))))
                       (when (= lvl 4) (setf *shell-debug* t))
                       (setf *note-level* lvl))))


;;; Run optimization
(note 1 "Evaluating the original.")
(setf (fitness *orig*) (test *orig*))

;; sanity check
(if (< (fitness *orig*) infinity)
    (note 2 "Original program has fitness ~a" (fitness *orig*))
    (throw-error "Original program has no fitness!"))

;; populate population
(note 1 "Building the Population")
(setf *population*
      (loop :for n :below *max-population-size* :collect (copy *orig*)))

(note 1 "Kicking off ~a optimization threads" *threads*)
(if (> *threads* 1)
    (let (threads)
      (loop :for n :below *threads* :do
         (push (sb-thread:make-thread (lambda () (evolve #'test :max-evals *evals*)))
               threads))
      (mapc #'sb-thread:join-thread threads))
    (evolve #'test :max-evals *evals*))

(note 1 "done after ~a fitness evaluations" *fitness-evals*)
