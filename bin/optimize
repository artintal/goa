#!/usr/bin/sbcl --script
;; -*- mode: lisp -*-
;;
;; Usage: optimize program test [OPTIONS...]
;;  Optimize a benchmark program against a test script
;;
;; Options:
;;  -l,--linker LINKER ---- linker to use
;;  -t,--threads NUM ------ number of threads
;;  -w,--work-dir DIR ----- use an sh-runner/work directory
;;  -r,--res-dir DIR ------ save results to dir
;;                          default: program.opt/
;;  -E,--max-error NUM ---- maximum allowed error
;;  -m,--model NAME ------- model name
;;  -T,--tourny-size NUM -- tournament size
;;                          default: 4
;;  -e,--max-evals NUM ---- max number of fitness evals
;;                          default: 2^18
;;  -p,--pop-size NUM ----- population size
;;                          default: 2^9
;;  -P,--period NUM ------- period (in evals) of checkpoints
;;                          default: max-evals/(2^10)
;;  -v,--verbose NUM ------ verbosity level 0-4
;;
;; Notes:
;;  If you require more working memory on your system,
;;  build sbcl with the following.
;;
;;    ./make.sh --dynamic-space-size=SIZE
;;
;; TODO:
;; - switch this from a shell script to a compiled
;;   application (buildapp) for faster startup
;;

;;; Code:
(let ((*error-output* (make-broadcast-stream)))
  (load (merge-pathnames ".sbclrc" (user-homedir-pathname))))
(load "bin/common.lisp")
(in-package :optimize)


;;; Help info, argument processing and variables initialization
(defvar *help*
  (with-open-file (in "bin/optimize")
    (read-line in) (read-line in) (read-line in) ;; discard first few lines
    (mapconcat (lambda (it) (subseq it (min (length it) 3)))
               (loop :for line = (read-line in nil)
                  :while (and line
                              (>= (length line) 2)
                              (string= (subseq line 0 2) ";;"))
                  :collect line) (format nil "~%"))))
(when (< (length sb-ext:*posix-argv*) 2)
  (throw-error "insufficient number of arguments~%~%~a" *help*))

(when (or (string= (subseq (car sb-ext:*posix-argv*) 0 2) "-h")
          (string= (subseq (car sb-ext:*posix-argv*) 0 3) "--h"))
  (throw-error "~a~%" *help*))

(setf *path* (arg-pop))
(setf *script* (arg-pop))
(setf *orig* (from-file (make-instance 'asm-perf) *path*))
(setf *res-dir* (append (pathname-directory *path*)
                        (list (concatenate 'string
                                (pathname-name *path*) ".opt"))))

(getopts
 ("-l" "--linker"    (setf (linker *orig*) (arg-pop)))
 ("-t" "--threads"   (setf *threads* (parse-integer (arg-pop))))
 ("-T" "--tourny-size" (setf *tournament-size* (parse-integer (arg-pop))))
 ("-e" "--max-evals" (setf *evals* (parse-integer (arg-pop))))
 ("-w" "--work-dir"  (setf *work-dir* (arg-pop)))
 ("-E" "--max-err"   (setf *max-err* (read-from-string (arg-pop))))
 ("-p" "--pop-size"  (setf *max-population-size* (parse-integer (arg-pop))))
 ("-m" "--model"     (setf *model* (intern (string-upcase (arg-pop)))))
 ("-P" "--period"    (setf *period* (parse-integer (arg-pop))))
 ("-v" "--verb"      (let ((lvl (parse-integer (arg-pop))))
                       (when (= lvl 4) (setf *shell-debug* t))
                       (setf *note-level* lvl)))
 ("-r" "--res-dir"   (setf *res-dir*
                           (let ((dir (arg-pop)))
                             (pathname-directory
                              (if (string= (subseq dir (1- (length dir))) "/")
                                  dir
                                  (concatenate 'string dir "/")))))))

(unless *period* (setf *period* (ceiling (/ *evals* (expt 2 10)))))

;; directories for results saving and logging
(unless (ensure-directories-exist (make-pathname :directory *res-dir*))
  (throw-error "Unable to make result directory `~a'.~%" *res-dir*))
(let ((log-name (make-pathname :directory *res-dir* :name "log" :type "txt")))
  (if (probe-file log-name)
      (throw-error "Log file already exists ~S.~%" log-name)
      (push (open log-name :direction :output) *note-out*)))

(unless *model*
  (setf *model* (case (arch)
                  (:intel 'intel-sandybridge-energy-model)
                  (:amd   'amd-opteron-energy-model))))
(note 1 "Optimizing against `~a'.~%" *model*)
(setf *model* (eval *model*))

;; save out configuration parameters
(note 1 "Parameters:~%~S~%"
      (mapcar (lambda (param)
                (cons param (eval param)))
              '(*path*
                *script*
                (linker *orig*)
                *threads*
                *tournament-size*
                *evals*
                *work-dir*
                *max-err*
                *max-population-size*
                *model*
                *period*
                *note-level*
                *res-dir*)))


;;; Run optimization
(note 1 "Evaluating the original.")
(setf (fitness *orig*) (test *orig*))

;; sanity check
(note 2 "Original program has fitness ~a" (fitness *orig*))
(when (= (fitness *orig*) infinity)
  (throw-error "Original program has no fitness!"))

;; populate population
(note 1 "Building the Population")
(setf *population*
      (loop :for n :below *max-population-size* :collect (copy *orig*)))

;; run optimization
(note 1 "Kicking off ~a optimization threads" *threads*)

(defun do-optimize ()
  (evolve #'test :max-evals *evals* :period *period* :period-func #'checkpoint))

(let (threads)
  ;; kick off optimization threads
  (loop :for n :below *threads* :do
     (push (sb-thread:make-thread #'do-optimize) threads))
  ;; wait for all threads to return
  (mapc #'sb-thread:join-thread threads))

(sb-ext:gc :force t)
(store *population* (make-pathname :directory *res-dir*
                                   :name "final-pop"
                                   :type "store"))

(note 1 "done after ~a fitness evaluations" *fitness-evals*)
(close (pop *note-out*))
