#+Title: optimize.lisp
#+Author: Eric Schulte
#+Style: <link rel="stylesheet" href="docco.css" type="text/css">
#+Property: tangle optimize.lisp

Optimize metrics in a population of software variants.

Starting with an initial software object, generate a population of
variant implementations and then evolve to optimize some metric such
as fastest execution, least communication, lowest energy consumption
etc...  For more complete notes on this experiment (still early
stages) see my [[http://cs.unm.edu/~eschulte/code/opt/optimization.html][notes and reproducibility instructions]].
#+begin_src lisp :padline no
  ;;; optimize.lisp --- optimize metrics in a population of software variants

  ;; Copyright (C) 2012  Eric Schulte

  ;;; Commentary:

  ;; Starting with an initial software object, generate a population of
  ;; variant implementations and then evolve to optimize some metric
  ;; such as fastest execution, least communication, lowest energy
  ;; consumption etc...
#+end_src

First load up the [[http://cs.unm.edu/~eschulte/code/software-evolution/README.html][Software Evolution]] library providing classes for
software representations and functions for mutating representations
and evolving population.  The git repository for this code is
available at http://gitweb.adaptive.cs.unm.edu/software-evolution.git.
#+begin_src lisp
  ;;; Code:
  (require :software-evolution)
  (in-package :software-evolution)
#+end_src

If running on one of the 48-core lab machines, set the thread pool
size to 46 (one for each VM backend) so that we can perform fitness
evaluations in parallel.
#+begin_src lisp
  ,#+lab-machine
  (advise-thread-pool-size 46)
#+end_src

Setup some global variables and set configurations -- similar to what
we would do with command-line flags in genprog.
#+begin_src lisp
  (defvar *pop*   nil "Population of variants.")
  (defvar *dir*   nil "Optional sub-directory in which to store results.")
  (defvar *file-format* "biased-pop-~S.store" "File name format.")
  (defvar *psize* 100 "Population size.")
  (defvar *tsize* 2   "Tournament size.")
#+end_src

Notice that I'm defining a different interface for the test script,
since it handles passing evaluating off to a virtual machine and given
that it return a complex fitness representation consisting of a number
of lines holding key-value pairs.  The =evaluate= function below will
parse this output and make the appropriate changes to the individual.

This [[http://cs.unm.edu/~eschulte/code/opt/src/host-test.sh][host-test.sh]] script and the [[http://cs.unm.edu/~eschulte/code/opt/src/guest-test.sh][guest-test.sh]] script are used to
distribute evaluation across a pool of VM back ends.
#+begin_src lisp
  (defvar *script* "./host-test.sh"
    "Script used to evaluate variants.
  Note: This does not follow the normal test script format but rather it;
  1. takes the path to a .s asm file
  2. copies that file to a VM
  3. runs the resulting program in Graphite in the VM
  4. returns the full set of Graphite debug information")
#+end_src

Here I sub-class the asm representation which itself sub-classes the
generic software representation class.  I basically just add a bunch
of fields to the class corresponding to performance metrics which I'll
like to track.  Most of these are communication based and are all
output by the [[http://groups.csail.mit.edu/carbon/?page_id=111][Graphite]] emulator.
#+begin_src lisp
  (defclass pll-asm (asm)
    ((neutral-p      :accessor neutral-p      :initform nil)
     ;; execution stats
     (start          :accessor start          :initform nil)
     (init-finish    :accessor init-finish    :initform nil)
     (finish         :accessor finish         :initform nil)
     (trans-fraction :accessor trans-fraction :initform nil)
     (time-wo-init   :accessor time-wo-init   :initform nil)
     (time-w-init    :accessor time-w-init    :initform nil)
     (raw-output     :accessor raw-output     :initform nil)
     (trans-time     :accessor trans-time     :initform nil)
     ;; network stats
     (total-packets-sent :accessor total-packets-sent :initform nil)
     (total-flits-sent :accessor total-flits-sent :initform nil)
     (total-bytes-sent :accessor total-bytes-sent :initform nil)
     (total-packets-broadcasted :accessor total-packets-broadcasted :initform nil)
     (total-flits-broadcasted :accessor total-flits-broadcasted :initform nil)
     (total-bytes-broadcasted :accessor total-bytes-broadcasted :initform nil)
     (total-packets-received :accessor total-packets-received :initform nil)
     (total-flits-received :accessor total-flits-received :initform nil)
     (total-bytes-received :accessor total-bytes-received :initform nil)
     (average-packet-latency-in-clock-cycles
      :accessor average-packet-latency-in-clock-cycles :initform nil)
     (average-packet-latency-in-ns
      :accessor average-packet-latency-in-ns :initform nil)
     (average-contention-delay-in-clock-cycles
      :accessor average-contention-delay-in-clock-cycles :initform nil)
     (average-contention-delay-in-ns
      :accessor average-contention-delay-in-ns :initform nil)
     (switch-allocator-traversals
      :accessor switch-allocator-traversals :initform nil)
     (crossbar-traversals :accessor crossbar-traversals :initform nil)
     (link-traversals :accessor link-traversals :initform nil))
    (:documentation
     "Extending the ASM class with a number of parallel run statistics."))

  (defun pll-to-s (var)
    "Write VAR to a temporary .s file."
    (let ((tmp (temp-file-name "s"))) (asm-to-file var tmp) tmp))

  (defun pll-from-asm (asm)
    (make-instance 'pll-asm :genome  (copy (genome asm))))
#+end_src

I load up the original program into a global variable for use later
on.  I'm not using any fault localization because I'd like the
mutations to be applied uniformly across the entire program -- I'm
searching through program space, not fixing bugs.
#+begin_src lisp
  (defvar *orig* (pll-from-asm (asm-from-file "../data/fft.s"))
    "Original seed program.")
#+end_src

Custom evaluation function.  In this case I'm not using any of the
built-in evaluation framework because it is easier to just call the
test script directly and modify the representations myself.
Evaluation runs the shell script saving all output from STDOUT into
the =output= variable which is saved in the =raw-output= field of the
variant.  This output is then parsed and used to fill in the relevant
variant metrics using the =apply-output= function.

If the test script returns a 0 exit code then the variant is neutral
and the =neutral-p= field is set to true.
#+begin_src lisp
  (defmethod evaluate ((var pll-asm))
    "Run parallel program VAR collecting and saving neutrality and all metrics."
    (let ((s-file (pll-to-s var)))
      (handler-case
          (with-timeout (360)
            (multiple-value-bind (output err exit) (shell "~a ~a" *script* s-file)
              (declare (ignorable err))
              (delete-file s-file)
              (note 2 "$ ~a ~a; $? => ~d" *script* s-file exit)
              (setf (raw-output var) output)
              (apply-output var (raw-output var))
              (setf (neutral-p var) (= exit 0))
              var))
        (timeout-error (c)
          (declare (ignore c))
          var))))
#+end_src

These functions parse the text output into keys and values which are
then saved in the appropriate fields of the individual variant.
#+begin_src lisp
  (defun output-to-stats (output)
    (delete nil
            (mapcar
             (lambda (line)
               (when (> (length line) 0)
                 (let* ((pair (split-sequence #\Space line :remove-empty-subseqs t))
                        (key  (read-from-string (car pair)))
                        (val  (mapcar #'read-from-string (cdr pair))))
                   (cons key val))))
             (split-sequence #\Newline output :remove-empty-subseqs t))))

  (defun apply-output (var output)
    (mapcar (lambda (pair)
              (let ((key (car pair)) (val (cdr pair)))
                (when (and key (slot-exists-p var key))
                  (setf (slot-value var key)
                        (if (= (length val) 1) (first val) val)))))
            (output-to-stats output)))
#+end_src

Two small helper functions used in =take-biased-step= below.
- file-for-run :: returns file names for saving of intermediate
     populations to files for later analysis and possible re-running
     -- this is useful for check pointing long runs.
- safe< :: is a version of =<= which protects against empty fields due
     to incomplete or non-standard program output.
#+begin_src lisp
  (defun file-for-run (n &optional (dir *dir*))
    (let ((file (format nil *file-format* n)))
      (if dir (merge-pathnames file dir) file)))
  
  (defun safe< (a b)
    "A version of < which gives the right values in the case of non-numbers."
    (if (numberp a) (if (numberp b) (< a b) T) nil))
#+end_src

Take a single biased step neutral space.  My /neutral space/ we mean
that only those individuals which have full fitness (i.e., pass the
only test) are considered, and by /biased/ we mean that out of the
neutral individuals we select we use simple tournament selection in
=new-var= to select those who have the attributes we like.  These
attributes are specified using the =test= and =key= keyword arguments
to this function.
- key :: is a function which is called on the individuals to yield
     some comparable metric (e.g., the running time)
- test :: is a function which is called on the results of the =key=
     function to specify what we like in that metric (e.g., =safe<=
     meaning "we want the smaller, but fail gracefully if it isn't a
     number")
#+begin_src lisp
  (defun biased-step (pop &key (test #'safe<) (key #'time-wo-init) &aux result)
    "Take a whole-population biased step through neutral space."
    (flet ((new-var ()
             (let ((t-pop (repeatedly *tsize* (random-elt pop))))
               (evaluate (mutate (copy (first (sort t-pop test :key key))))))))
      (loop :until (>= (length result) *psize*) :do
         (let* ((to-run (min (thread-pool-size)
                             (floor (* (- *psize* (length result)) 3))))
                (pool (progn
                        (note 1 "~&generating ~a" to-run)
                        (prepeatedly to-run (progn (note 2 "starting")
                                                   (new-var))))))
           (note 1 "~&keeping the fit")
           (dolist (var pool) (when (neutral-p var) (push var result)))
           (note 1 "~&(length results) ;; => ~a" (length result))))
      (subseq result 0 *psize*)))
#+end_src

Just a collection of biased steps with some minimal note-keeping in
the middle.
#+begin_src lisp
  (defun biased-walk (seed &key (steps 100) (test #'safe<) (key #'time-wo-init))
    "Evolve a population in the neutral space biased by metric and KEY."
    (setf *pop* (list seed))
    (dotimes (n steps)
      (note 1 "saving population ~d" n)
      (store *pop* (file-for-run n))
      (note 1 "generating population ~d" (1+ n))
      (setf *pop* (biased-step *pop* :test test :key key))))
#+end_src

This is the command which is actually issued on the server to run
evolution.
#+begin_src lisp
  ,#+run
  (biased-walk *orig*)
#+end_src

# Local Variables:
# org-export-html-postamble: nil
# org-export-html-style-include-default: nil
# org-docco-doccoize-me: t
# End:
