Optimization Notes  -*- mode:org; org-attach-directory:"etc/data/" -*-
#+Options: ^:{}

* Work Plan
:   train energy    memory       benchmarks       baselines       write
:     models      fitness func       |         (Rinard, O2 O3)      |
:      |              |              |                |             |
:      |              v              |                v             |
:      +--> begin evolutionary <-----+------------> apply           |
:                 runs                            baselines         |
:                  |                                  |             |
:                  v                                  v             |
:            lists of bests --------------> compare performance     |
:                  |                        against baselines       |
:                  v                                  |             |
:             minimize and                            |             |
:               analyze                               |   table     |
:                  |                                  |  results    |
:                  |                                  +------------>|
:        +---------+----------+                                     |
:        |                    |                                     |
:        v                    v                                     |
:    taxonomy of      compare to known                              |
:   optimizations       techniques             find loop            |
:        |                    |               perforation, etc...   |
:        |                    +------------------------------------>|
:        |                                                          |
:        |                                                          |
:        |                                      taxonomy            |
:        +--------------------------------------------------------->|
:                                                                   |
:                                                                   |
:                                                                   v
:                                                                finished
:                                                                 paper

** Optional Additional Topics
- Breeders :: apply the Breeders Equation to analyze the relations
              between software traits and predict directions of
              software evolution

- Pareto :: return a Pareto frontier of solutions as a result of
            optimization rather than a single individual

- MCMC :: our mutation operations are nearly MCMC compliant already,
          with some small changes we should be able to implement MCMC
          as a search strategy

* Notes
** Benchmarks
Perhaps these Fortran programs would make a suitable addition to our
benchmark suites.  http://www.polyhedron.com/MFL6VW74649

*** PARSEC applications
| Program      | Language   | parallel      | test difficulty | working set | communication |
|--------------+------------+---------------+-----------------+-------------+---------------|
| blackscholes | C/CPP      | data parallel | easy            | small       | negligible    |
| bodytrack    | CPP        | pipeline      | hard            |             |               |
| facesim      | C/CPP      | data parallel | hard            |             |               |
| ferret       | C          | pipeline      | hard            | huge        | very much     |
| fluidanimate | CPP        | data parallel | easy            | large       | some          |
| freqmine     | CPP/OpenMP | data parallel | medium          | huge        | some          |
| raytrace     | C/OpenGL   | data parallel |                 | large       | little        |
| swaptions    | CPP        | data parallel |                 | medium      | little        |
| vips         | C          | data parallel | medium (image)  | medium      | some          |
| x264         | C          | pipeline      | medium (video)  | medium      | very          |

*** SPEC
| program        |
|----------------|
| 400.perlbench  |
| 401.bzip2      |
| 403.gcc        |
| 410.bwaves     |
| 416.gamess     |
| 429.mcf        |
| 433.milc       |
| 434.zeusmp     |
| 435.gromacs    |
| 436.cactusADM  |
| 437.leslie3d   |
| 444.namd       |
| 445.gobmk      |
| 447.dealII     |
| 450.soplex     |
| 453.povray     |
| 454.calculix   |
| 456.hmmer      |
| 458.sjeng      |
| 459.GemsFDTD   |
| 462.libquantum |
| 464.h264ref    |
| 465.tonto      |
| 470.lbm        |
| 471.omnetpp    |
| 473.astar      |
| 481.wrf        |
| 482.sphinx3    |
| 483.xalancbmk  |
| 998.specrand   |
| 999.specrand   |

* Tasks [18/35]
** TODO find minimal input sizes for each program
Need to estimate the variance in our energy predictions, which are
linear combinations of HW counters, from variance in the HW counters.

So that we can reduce test input sizes (which increases variance in
the HW counters) until the variance in our predictions become too high
to accurately guide our GP process.

The goal is to balance faster running time with fitness function
accuracy.

For every benchmark program, test a range of input sizes until we find
the smallest input which results in stable HW counters.

The HW counters are definitely correlated, so we should use something
like the following.
http://wikipedia.org/wiki/Variance#Sum_of_correlated_variables

*** TODO minimum input size for each program
| Program      | size |
|--------------+------|
| blackscholes |      |
| bodytrack    |      |
| facesim      |      |
| ferret       |      |
| fluidanimate |      |
| freqmine     |      |
| raytrace     |      |
| swaptions    |      |
| vips         |      |
| x264         |      |

*** DONE Step by step process for energy minimization
    DEADLINE: <2013-06-11 Tue>
    :PROPERTIES:
    :shebang:  #!/bin/bash
    :END:

1. Perform 30 runs collecting counters for each size.
   #+begin_src sh :tangle stats-by-input
     bench=$1
     for size in test tiny small medium large;do
         mgmt clean $bench >&2
         mgmt output $bench -s $size >&2
         echo ""
         echo $size
         for i in {1..30};do
             run $bench benchmarks/$bench/$bench -s $size -p
         done
     done > results/counters-by-input-size/$bench.txt
   #+end_src

2. Clean up the stats and organize by size.
   #+begin_src sh :tangle clean-input-stats
     bench=$1
     for size in test tiny small medium large;do
         cat results/counters-by-input-size/$bench.txt \
             |sed -n "/$size/,/^$/p"|grep ","|sed 's/,/ /' \
             |awk '{print $2, $1}'|sort \
             > results/counters-by-input-size/$bench-$size.txt
     done
   #+end_src

3. Using the architecture-specific model, calculate the variance of
   the model for each size based on the counter values for that size.
   Use the technique described in
   [[http://en.wikipedia.org/wiki/Variance#Weighted_sum_of_variables][wikipedia/Variance#Weighted_sum_of_variables]].
   #+begin_src lisp :var benchmark="blackscholes"
     (in-package :optimize)

     (defun counters (bench size)
       (let* ((base "results/counters-by-input-size")
              (raw (file-to-string (format nil "~a/~a-~a.txt" base bench size)))
              vals)
         (mapc (lambda-bind ((counter count))
                 (if (assoc counter vals)
                     (push count (cdr (assoc counter vals)))
                     (push (list counter count) vals)))
               (mapcar (lambda (list)
                         (cons (make-keyword (string-upcase (car list)))
                               (mapcar #'read-from-string (cdr list))))
                       (mapcar {split-sequence #\Space}
                               (split-sequence #\Newline raw
                                               :remove-empty-subseqs t))))
         vals))

     (defun covariance (a b)
       (/ (reduce #'+ (mapcar #'*
                              (mapcar {- _ (mean a)} a)
                              (mapcar {- _ (mean b)} b)))
          (- (length a) 1)))

     ;; http://en.wikipedia.org/wiki/Variance#Weighted_sum_of_variables
     (defun weighted-sum-of-var (model samples)
       "Return the weighted variance of MODEL given SAMPLES."
       (let ((mod (mapcar (lambda-bind ((a b)) (cons b a)) model)))
         (loop :for i :in (mapcar #'car mod) :summing
            (loop :for j :in (mapcar #'car mod) :summing
               (* (aget i mod) (aget j mod)
                  (covariance (aget i samples) (aget i samples)))))))

     (let ((sizes (list "test" "tiny" "small" "medium" "large"))
           (model amd-opteron-energy-model))
       (list sizes
             (mapcar [{weighted-sum-of-var model} {counters benchmark}] sizes)))
   #+end_src

   #+RESULTS:
   |          test |          tiny |         small |        medium |         large |
   | 1.9632377e-14 | 1.3618151e-13 | 6.0662375e-13 | 1.6117804e-12 | 2.6060975e-11 |

4. Find the mean calculated energy for each run.

5. Pick the smallest input size which keeps variance within some
   fraction of the output (TBD).

**** fluidanimate
#+begin_src sh :results silent
  for size in test tiny small medium large;do
      mgmt clean fluidanimate >&2         
      mgmt output fluidanimate -s $size >&2
      echo "";echo $size
      run fluidanimate benchmarks/fluidanimate/fluidanimate -s $size -r 30
  done|tee results/counter-by-size/fluidanimate.txt
#+end_src

** TODO Build all benchmarks to ASM [9/10]
*** parsec
**** DONE Blackscholes
**** DONE bodytrack
Here is the command I used to make an executable from the assembly file.
    (note :/nfs/adaptive/stharding/tmp/parsec-3.0 should be replaced with
    the path to parsec)
: g++ -L /nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/bodytrack/obj/amd64-linux.gcc/FlexImageLib/.libs/  -L /nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/bodytrack/obj/amd64-linux.gcc/TrackingBenchmark/threads/.libs/ bodytrack.s -o bodytrack -lflex -lpthread -lthreads
And here is the command I used to make the asm file (note the relative
    paths. Might be a good idea to change to absolute paths) see the
    management script to make the cpp file (also, I think it is necessary
    to build with the parsec management script first so that the config.h
    file will be generated.)
:
: g++ -DHAVE_CONFIG_H -I. -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/bodytrack/src/FlexImageLib -I.. -O3 -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions  -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -fexceptions  -MT FlexImage.lo -MD -MP -MF ../../obj/amd64-linux.gcc/FlexImageLib/.deps/FlexImage.Plo -I ../../obj/amd64-linux.gcc/ -L ../../obj/amd64-linux.gcc/FlexImageLib/.libs/ -I ../../../../libs/tbblib/src/include/ -L../../../../libs/tbblib/src/include/ -L ../../obj/amd64-linux.gcc/TrackingBenchmark/threads/.libs/ -S tst.cpp -o bodytrack.s -lflex -lpthread -lthreads

**** DONE facesim
To make ASM file:
first in the directory <path to parsec>/pkgs/apps/facesim/src/Benchmarks/facesim/:
: cat FACE_DRIVER.cpp FACE_LANDMARK_OPTIMIZATION_GOAL.cpp FACE_OPTIMIZATION.cpp LANDMARK_PROXIMITY_OPTIMIZATION.cpp main.cpp >all.cpp
then:
: g++ -O3 -w -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions -static-libgcc -pthread -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -fexceptions -DENABLE_PTHREADS -DUSE_ALAMERE_TASKQ -DNDEBUG -I../../../obj/amd64-linux.gcc/TaskQ/include -L../../../obj/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib ../../../obj/amd64-linux.gcc/TaskQ/lib/taskQ.o -S all.cpp -lPhysBAM -xW -lm

To build the executable:
: g++ -L../../../obj/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib ../../../obj/amd64-linux.gcc/TaskQ/lib/taskQ.o all.s -o facesim -pthread -lPhysBAM -xW -lm

**** DONE ferret

To make the .S file:
First build with the parsec build tool
   (NOTE: this will fail unless you edit the makefiles in the gsl lib src directory.
   you must remove `doc' from SUBDIRS in both makefiles for gsl to build)
   Then, in the directory: <path to parsec>/pkgs/apps/ferret/obj/amd64-linux.gcc/benchmark
   (change /nfs/adaptive/stharding/tmp/parsec-3.0/ to your path to parsec):

   : gcc -w -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/ferret/src/include/ -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/libs/gsl/inst/amd64-linux.gcc/include -I/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/libjpeg/inst/amd64-linux.gcc/include  -O3 -g -funroll-loops -fprefetch-loop-arrays -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/gsl/inst/amd64-linux.gcc/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/libjpeg/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/ferret/inst/amd64-linux.gcc/lib/ -S ferret-pthreads.c -lrt -lcass -lgsl -lcassimage -lgslcblas -ljpeg -lstdc++ -lpthread -lm

To make the executable:
   : gcc -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/gsl/inst/amd64-linux.gcc/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/libjpeg/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/ferret/inst/amd64-linux.gcc/lib/ ferret-pthreads.s -o ferret -lrt -lcass -lgsl -lcassimage -lgslcblas -ljpeg -lstdc++ -lpthread -lm

NOTE: there are other versions of ferret that can be built. This is the one that is built
      by default when you do ./parsecmgmt -a build -p ferret

**** DONE fluidanimate
**** DONE freqmine
1. cat all .cpp files together
2. remove duplicates of
   : include "common.h"
3. remove the second duplicate of the =omp_get_max_threads()=

**** DONE raytrace
To make the .S file:
First build raytrace by using the parsec mgmt tool. Then in pkgs/apps/raytrace/src/MiniView:

: g++ -DTHIS_IS_CMAKE -I/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/mesa/inst/amd64-linux.gcc/include -O3 -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -fexceptions -fno-strict-aliasing -fno-align-labels -DNDEBUG -D_MM_NO_ALIGN_CHECK  -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/RTTL -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/RTTL/common -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/RTTL/BVH -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/SG -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/LRT/include -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/LRT -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/mesa/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/libs/mesa/inst/amd64-linux.gcc/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/lib -S rtview.cxx -rdynamic  -lglut -lGL -lGL -lGLU -lXmu -lXext -lXau -lX11 -ldl -lpthread -lstdc++ -lpthread -lrt -lglut -lGL -lGL -lGLU -lXmu -lXext -lXau -lX11 -ldl -lpthread -lstdc++ -lrt

To make the executable: (updated to remove excess flags)
: g++  -L ../../../../libs/mesa/inst/amd64-linux.gcc/lib  rtview.s -o rtview    ../../obj/amd64-linux.gcc/lib/libLRT.a ../../obj/amd64-linux.gcc/lib/libRTTL.a  -lglut  -lGL -lGLU -lXmu -lXext -lXau -lX11 -ldl -lpthread -lstdc++ -lrt -rdynamic

**** DONE swaptions
#+begin_src sh
  cat *.c* > swaptions.cpp
  g++ -S swaptions.cpp
  g++ swaptions.s -o swaptions2
#+end_src

**** DONE vips
     It turns out that the bulk of the computation is done in the library libvips.a so the solution described below is not very good.
     Instead, we separate libvips.a into two parts and generate an asm file for the part we intend to evolve. See bin/libvips.sh

     ------------------------------------------------------------------------------

     In the directory: <path to parsec>/parsec-3.0/pkgs/apps/vips/src/tools/iofuncs
     compile vips to assembly by:
     gcc -std=gnu99 -DHAVE_CONFIG_H -I. -I../../ -I../../libvips/include -DG_DISABLE_CAST_CHECKS -pthread -I ../../../../../libs/libxml2/inst/amd64-linux.gcc/include/libxml2 -I../../../../../libs/glib/inst/amd64-linux.gcc/lib/glib-2.0/include -I../../../../../libs/glib/inst/amd64-linux.gcc/include/glib-2.0/  -I../../../obj/amd64-linux.gcc/  -O3 -g -funroll-loops -fprefetch-loop-arrays -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -L../../../inst/amd64-linux.gcc/lib/  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -DG_DISABLE_CAST_CHECKS -I../../../../../libs/libxml2/inst/amd64-linux.gcc/include/libxml2 -I../../../../../libs/glib/inst/amd64-linux.gcc/lib/glib-2.0/include -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/libxml2/inst/amd64-linux.gcc/lib -S vips.c  -lgobject-2.0 -lgthread-2.0 -pthread    -lvips   -lm  -lstdc++ -lxml2 -lgmodule-2.0 -ldl -lglib-2.0

     To make an executable:
     gcc -L../../../inst/amd64-linux.gcc/lib/  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -DG_DISABLE_CAST_CHECKS -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/libxml2/inst/amd64-linux.gcc/lib vips.s  -lgobject-2.0 -lgthread-2.0 -pthread    -lvips   -lm  -lstdc++ -lxml2 -lgmodule-2.0 -ldl -lglib-2.0
**** TODO x264
*** SPEC
**** 400.perlbench
**** 401.bzip2
**** 403.gcc
**** 410.bwaves
**** 416.gamess
**** 429.mcf
**** 433.milc
**** 434.zeusmp
**** 435.gromacs
**** 436.cactusADM
**** 437.leslie3d
**** 444.namd
**** 445.gobmk
**** 447.dealII
**** 450.soplex
**** 453.povray
**** 454.calculix
**** 456.hmmer
**** 458.sjeng
**** 459.GemsFDTD
**** 462.libquantum
**** 464.h264ref
**** 465.tonto
**** 470.lbm
**** 471.omnetpp
**** 473.astar
**** 481.wrf
**** 482.sphinx3
**** 483.xalancbmk
**** 998.specrand
**** 999.specrand
** DONE Select Energy Models [2/2]
\begin{equation*}
  kwh = c_{1} + c_{2} \times cyc + c_{3} \times ins + c_{4} \times ops + c_{5} \times tca + c_{6} \times mem
\end{equation*}

| metric                 | perf              |
|------------------------+-------------------|
| cyc                    | cycles            |
| ins                    | instructions      |
| ops(AMD Opteron)       | r533f00           |
| ops(Intel Sandybridge) | r532010 + r538010 |
| tca                    | cache-references  |
| mem                    | cache-misses      |

*** Measuring required counters with =perf=
Not all counters are provided by default, so we need to use HW
specific raw event.  According to [[http://web.eece.maine.edu/~vweaver/projects/perf_events/faq.html#q2e][this faq]] to find the appropriate
code for the raw events grab [[http://perfmon2.sourceforge.net/][libpfm4]] from [[http://sourceforge.net/projects/perfmon2/files/][here]].  Then unpack the
files, build, and browse the available raw events with the following.

#+begin_src sh
  cd libpfm-4.3.0
  make
  cd example
  ./showevtinfo -E|less
#+end_src

The resulting hex value can then be passed to perf by prefixing it
with an "r".

*** DONE AMD energy model
: perf stat -e cycles,instructions,r533f00,cache-references,LLC-loads,LLC-stores -- command

*** DONE Intel energy model
: perf stat -e cycles,instructions,r532010,r538010,cache-references,LLC-loads,LLC-stores

** TODO Train Energy Models [1/6]
Both at UVA on Intel and at UNM on AMD.

*** TODO retrain the energy models with evolved individuals
Use sampling used in [[#evolved-energy-consumption]], dump through objread
to get stats, combine those stats with watts-up output in
results/energy-final-metrics, combine *that* with original training
data, and re-train the model.

*** constrain the model to pass through the origin
Cycles is a proxy for time, so 0 counters should imply 0 kwh.

*** TODO include last two benchmark programs [0/2]
    DEADLINE: <2013-06-11 Tue>
- [ ] x264 from parsec (compiled)
- [ ] dealII from SPEC

*** TODO compile both of these last two benchmark programs [1/2]
- [X] x264 from parsec (compiled)
- [ ] dealII from SPEC

**** TODO DealII
This discussion looks to be relevant to our build problems.
http://gcc.gnu.org/bugzilla/show_bug.cgi?id=44416

See this discussion of how to use alternate sources.
http://www.spec.org/cpu2006/Docs/config.html#sectionIX

See the list of alternate sources by SPEC version.
http://www.spec.org/cpu2006/src.alt/

See the particular alternate source which must be applied for dealII
to compile.
http://gcc.gnu.org/bugzilla/attachment.cgi?id=20848
http://www.spec.org/cpu2006/src.alt/447.dealII.explicit_inclusion_of_cstring.cpu2006.v1.0.tar.bz2

The command lines work out to be roughly
#+begin_src sh
  wget http://gcc.gnu.org/bugzilla/attachment.cgi?id=20848
  mv attachment.cgi\?id\=20848 447.dealII.cstddef.cpu2006.v1.1.tar.bz2
  specbzip2 -dc 447.dealII.cstddef.cpu2006.v1.1.tar.bz2 | spectar -xf  -
  echo "ext = without" > configs/without.cfg
  runspec --action buildsetup -T base -c without -v 1 447.dealII
  cat <<EOF > configs/with.cfg
  ext = with
  447.dealII:
  srcalt = cstddef
  EOF
  runspec --action buildsetup -T base -c with -v 1 447.dealII -I
  # now the changes have been applied, to then use the updated version
  # run the following where complex.cfg is replaced with the config file
  # for your system
  runspec --action build -c complex.cfg -v 1 447.dealII -I
#+end_src

*** DONE AMD Energy Model
| metric           | perf             | coefficient |
|------------------+------------------+-------------|
| cyc              | cycles           |   4.411e-14 |
| ins              | instructions     |   2.235e-15 |
| ops(AMD Opteron) | r533f00          |  -8.531e-16 |
| tca              | cache-references |  -1.256e-14 |
| mem              | cache-misses     |   3.679e-13 |

**** Collected raw data relating energy consumption to hw counters.
#+name: amd-energy-and-hw-metrics
| benchmark      | time |    kwh |         watts |        cycles |  instructions |       r533f00 | cache-references | cache-misses |
|----------------+------+--------+---------------+---------------+---------------+---------------+------------------+--------------|
| blackscholes   |  439 | 0.0405 | 333.007061503 |  963681322941 |  759844691381 |  440277963193 |     165728320541 |    140040400 |
| bodytrack      |  345 | 0.0325 |  339.41884058 |  733091005874 |  781067817081 |  405865777512 |     127287608572 |    245673468 |
| facesim        |  0.0 |    0.0 |           0.0 |      16560559 |      14789833 |       1693208 |          4697405 |        74581 |
| ferret         |  522 | 0.0507 | 350.532950192 | 1588471176139 | 1748909071671 |  508858865217 |     567858426857 |    100044775 |
| fluidanimate   |  650 | 0.0608 | 337.591076923 | 1433302012584 | 1677896998422 | 1002609778300 |     484568539692 |     21997404 |
| freqmine       |  849 | 0.0806 | 342.344051826 | 1848878873062 | 2450052339453 |      49431788 |     791028342362 |     66097064 |
| raytrace       |  378 | 0.0358 | 341.426190476 |  834912012589 | 1204834722923 |  646652063937 |     244447040716 |    841572881 |
| swaptions      |  580 |  0.054 | 335.989482759 | 1277170247920 | 1458456204847 |  613924489347 |     361402521432 |    150688646 |
| vips           |  233 | 0.0219 | 338.053218884 |  506403393629 |  770985463673 |  204387614153 |     143861054265 |    203743614 |
| sleep2         |    1 | 0.0001 |         325.0 |       1068673 |        628101 |          1790 |           238757 |         9261 |
| sleep5         |    4 | 0.0004 |       327.375 |       1069525 |        606630 |          1774 |           256435 |        10316 |
| sleep10        |    9 | 0.0008 | 326.233333333 |       1021646 |        626510 |          1721 |           247746 |        10388 |
| sleep30        |   29 | 0.0026 | 323.475862069 |       1019901 |        649767 |          1785 |           237688 |         9336 |
| sleep60        |   59 | 0.0052 | 321.937288136 |       1037259 |        618201 |          1769 |           229123 |         9201 |
| blackscholes   |  437 | 0.0405 | 334.313501144 |  962242554271 |  759823452448 |  440248110213 |     159457388792 |    129664715 |
| bodytrack      |  346 | 0.0323 | 336.672543353 |  733724456347 |  781057881137 |  405865621890 |     127240780364 |    193147096 |
| facesim        |  0.0 |    0.0 |           0.0 |      16043941 |      14867195 |       1688548 |          4719060 |        73992 |
| ferret         |  522 | 0.0503 | 347.481417625 | 1608827613673 | 1748979636562 |  508724194111 |     567547428624 |    101952537 |
| fluidanimate   |  649 | 0.0609 | 337.980585516 | 1438777004290 | 1677905068279 | 1003486864457 |     484679953040 |     21736128 |
| freqmine       |  848 | 0.0805 | 342.425707547 | 1843800403467 | 2450061993769 |      49425812 |     791415640031 |     66253490 |
| raytrace       |  377 | 0.0358 | 341.849867374 |  831780621631 | 1204809370390 |  646658574964 |     245001617881 |    937017963 |
| swaptions      |  578 | 0.0539 | 336.156747405 | 1274440983375 | 1458375779265 |  613619457154 |     362297763899 |     48489018 |
| vips           |  235 | 0.0221 | 338.945106383 |  497932290315 |  770623602908 |  203161466196 |     144316491452 |    206477267 |
| sleep2         |    1 |    0.0 |         325.3 |       1057931 |        621206 |          1792 |           232246 |         9312 |
| sleep5         |    4 | 0.0003 |         325.0 |       1061374 |        617416 |          1746 |           221495 |         9137 |
| sleep10        |    9 | 0.0008 | 324.377777778 |        956587 |        609894 |          1735 |           237629 |         9774 |
| sleep30        |   29 | 0.0026 | 323.289655172 |       1075075 |        644843 |          1736 |           228295 |         9522 |
| sleep60        |   59 | 0.0053 | 322.161016949 |       1116455 |        642621 |          1733 |           234232 |         9589 |
| blackscholes   |  439 | 0.0407 | 333.797266515 |  978537944311 |  759853135482 |  448108538602 |     159681951945 |    130110732 |
| bodytrack      |  345 | 0.0326 | 340.417971014 |  734430891707 |  781078301944 |  405901756994 |     127221390140 |    214104415 |
| facesim        |  0.0 |    0.0 |           0.0 |      15865765 |      14759180 |       1691132 |          4682768 |        73876 |
| 400.perlbench  |  172 | 0.0164 | 343.927325581 |  363205546396 |  673460255215 |     198103220 |     168940598894 |    448530688 |
| 401.bzip2      |  127 | 0.0121 |  341.48503937 |  280624033346 |  319812916322 |        268031 |     105223223290 |      6408514 |
| 403.gcc        |   24 | 0.0023 | 341.170833333 |   55270414187 |   52882913988 |     501470091 |      19001587893 |    137057463 |
| 410.bwaves     | 1930 | 0.1848 | 345.140725389 | 4237316105602 | 3340156118640 | 1608974718204 |     785753595114 |     86869305 |
| 416.gamess     |  259 | 0.0247 | 344.312741313 |  568989187150 | 1047126415135 |  404543004871 |     212818566730 |    122987990 |
| 429.mcf        |  996 | 0.0951 |  344.20060241 | 2117183253301 |  303695508258 |       4429256 |     122279702747 |     42132139 |
| 433.milc       |  616 | 0.0595 | 348.169967532 | 1361085107228 | 1181353371826 |  850005142260 |     211799352223 |     29960505 |
| 434.zeusmp     |  881 | 0.0839 | 343.000908059 | 1942840268672 | 1805419511735 | 1596582662098 |     407497075587 |     46809057 |
| 435.gromacs    |  859 | 0.0813 | 341.240861467 | 1891264738863 | 2160419213985 | 1734939474915 |     416863263346 |     60722123 |
| 436.cactusADM  | 1426 | 0.1357 | 343.065287518 | 3133609562731 | 2730087227455 | 2830219681072 |     649952731741 |     99446625 |
| 437.leslie3d   |  717 | 0.0693 | 348.251324965 | 1569704929576 | 1551526352154 | 1059334560787 |     321208209593 |     42223855 |
| 444.namd       |  708 | 0.0671 | 341.838700565 | 1556051397196 | 2257288024298 | 1682197205095 |     466800570445 |     30132681 |
| 445.gobmk      |  136 | 0.0129 | 341.908088235 |  299407520238 |  323819168201 |    1723948132 |     144389853031 |    639965759 |
| 450.soplex     |  302 | 0.0289 | 345.098675497 |  643362986038 |  358494728333 |  128977762038 |     102926641824 |     17581665 |
| 453.povray     |  324 | 0.0309 | 343.569135802 |  713862677233 |  945909381078 |  347548355646 |     279604811656 |   1312346898 |
| 454.calculix   | 1423 | 0.1354 | 342.999508082 | 3130626046436 | 6166081367888 | 3715717501412 |    1344503685294 |    201472325 |
| 456.hmmer      |  416 | 0.0398 | 345.001201923 |  915193135250 | 1878847157364 |   17603610038 |     284255339691 |     30323193 |
| 458.sjeng      |  906 | 0.0861 | 342.556622517 | 1996773046731 | 2200085290815 |       1221094 |     981587003984 |    455529921 |
| 459.GemsFDTD   |  882 | 0.0854 |  349.20521542 | 1925374860097 | 1566606447376 | 1173916753733 |     280276041570 |     43114955 |
| 462.libquantum |  972 | 0.0941 | 348.936419753 | 2096058789720 | 1856427541448 |    4331708084 |     643820893885 |     35091747 |
| 464.h264ref    |  939 | 0.0895 | 343.535463259 | 2056952424155 | 2426423692805 |    1438263416 |     512591933779 |    562704357 |
| 465.tonto      | 1571 | 0.1489 | 341.581667728 | 3471179796415 | 3147373470456 | 1734083749913 |     806146473044 |   1584069489 |
| 470.lbm        |  816 |  0.079 | 348.779901961 | 1797592416770 | 1261010132344 | 1219123374595 |     207620646064 |     29699997 |
| 471.omnetpp    |  542 | 0.0518 | 344.322693727 | 1156254727500 |  588222734645 |   60116420268 |     201985211961 |   2200652189 |
| 473.astar      |  423 | 0.0401 | 341.430023641 |  934367239164 |  815560161952 |     133140874 |     361211047283 |     20556701 |
| 481.wrf        |  0.0 |    0.0 |           0.0 |     593370968 |     711694385 |     107167259 |        154949631 |       161652 |
| 482.sphinx3    | 1181 | 0.1107 | 337.783149873 | 2595951183221 | 3349740098022 | 2190608682991 |     770495377859 |    202291716 |
| 998.specrand   |  0.0 |    0.0 |           0.0 |     350025649 |     563269510 |      20079782 |        161604673 |      1484586 |
| 999.specrand   |  0.0 |    0.0 |           0.0 |     362873259 |     563235015 |      20069938 |        161784725 |      1479227 |

**** Trained a linear model off of these counters
     :PROPERTIES:
     :eval:     no
     :END:
These two models were generated using the following.

#+begin_src sh
  power-model.R etc/data/combined-benchmarks.csv
#+end_src

kwh ~  cycles instructions fops cache.references cache.misses
|                  |   Estimate | Std. Error |      t |  value | Pr  |
|------------------+------------+------------+--------+--------+-----|
| (Intercept)      |  3.036e-04 |  7.203e-04 |  0.421 | 0.6751 |     |
| cycles           |  4.411e-14 |  1.069e-15 | 41.243 | <2e-16 | *** |
| instructions     |  2.235e-15 |  1.959e-15 |  1.141 | 0.2591 |     |
| fops             | -8.531e-16 |  1.292e-15 | -0.660 | 0.5119 |     |
| cache.references | -1.256e-14 |  6.340e-15 | -1.981 | 0.0527 | .   |
| cache.misses     |  3.679e-13 |  1.214e-12 |  0.303 | 0.7630 |     |

#+begin_src sh
  build_power_model.py --target=kwh \
    --model=cycles,instructions,flop,cache-references,cache-misses \
    etc/data/combined-benchmarks.csv
#+end_src

Modeling kwh
| cycles           |   4.4212e-14 |
| instructions     |  1.27494e-15 |
| flop             | -6.77546e-16 |
| cache-references | -8.60545e-15 |
| cache-misses     |  1.42351e-13 |
| constant         |  0.000410495 |

*** TODO Intel Energy Model
** DONE measure energy consumption of evolved programs
   DEADLINE: <2013-06-11 Tue>
   :PROPERTIES:
   :CUSTOM_ID: evolved-energy-consumption
   :END:
#+name: amd-results
| results/swaptions-all |
| results/bs-all        |
| results/bzip2-all     |
| results/freqmine-all  |
| results/fluid-all-2   |

1. For all finished runs, collect some of the best individuals and
   compile them to executables.
   #+begin_src sh :var dirs=amd-results
     for dir in $(echo "$dirs");do
         sample $dir 8|xargs -I{} objread {} -l {}.exe
     done
   #+end_src

2. Move all of the executables into a single results directory.
   #+begin_src sh :var dirs=amd-results
     mkdir -p results/best-energy-exes
     for dir in $(echo "$dirs");do
         base=$(basename $dir)
         for exe in $dir/best*exe;do
             mv $exe results/best-energy-exes/$base-$(basename $exe)
         done
     done
   #+end_src

3. Copy the originals into the results directory as well.
   #+begin_src sh
     for bench in blackscholes bzip2 fluidanimate freqmine swaptions;do
         mgmt clean $bench
         mgmt link $bench
         cp benchmarks/$bench/$bench results/best-energy-exes/$bench-orig
     done
   #+end_src

4. Normalize the names of the files in the results directory.

5. Ensure output exists for every benchmark
   #+begin_src sh
     for bench in blackscholes bzip2 fluidanimate freqmine swaptions;do
         mgmt output $bench -s large
     done
   #+end_src

6. Measure the energy consumption of each program in the results
   directory.
   #+begin_src sh
     for bench in blackscholes bzip2 fluidanimate freqmine swaptions;do
         for exe in results/energy-final-metrics/$bench-*;do
             for i in $(seq 0 9);do
                 echo -e "running $bench\t$exe\t$i"
                 sleep 10
                 wu.py -o $exe-$i.csv ttyUSB0 -- run $bench $exe -s large -r 20
             done
         done
     done
   #+end_src

7. Collect energy metrics for each program.
   #+name: energy-reduction
   #+begin_src sh :dir results/energy-final-metrics/
     mean(){
         awk '{
             for (i=1; i<=NF; i++)
             {
                 if($i ~ /[0-9.]/){sum[i] += $i; count[i]++}
                     if(i == 1){ line = sum[i]/count[i] }else{ line = line " " sum[i]/count[i]}
             }
             print line
         }'; }
     
     for prog in $(find ./ -perm 755);do
         echo "$(basename $prog|cut -d- -f1) $(basename $prog|cut -d- -f2) $(cat $prog*csv|grep -v time|cut -d, -f5|mean|tail -1)"
     done
   #+end_src

   #+RESULTS: energy-reduction
   | blackscholes |   orig |       0 |
   | blackscholes |  32768 |       0 |
   | blackscholes |  65536 |       0 |
   | blackscholes |  98304 |       0 |
   | blackscholes | 131072 |       0 |
   | blackscholes | 163840 |       0 |
   | blackscholes | 196608 |       0 |
   | blackscholes | 229376 |       0 |
   | blackscholes | 262144 |       0 |
   | bzip2        |   orig | 0.00032 |
   | bzip2        |  32768 |  0.0003 |
   | bzip2        |  65536 |  0.0003 |
   | bzip2        |  98304 |  0.0003 |
   | bzip2        | 131072 | 0.00029 |
   | bzip2        | 163840 |  0.0003 |
   | bzip2        | 196608 |  0.0003 |
   | bzip2        | 229376 |  0.0003 |
   | bzip2        | 262144 |  0.0003 |
   | fluidanimate |   orig | 0.00734 |
   | fluidanimate |  32768 | 0.00713 |
   | fluidanimate |  65536 | 0.00714 |
   | fluidanimate |  98304 | 0.00708 |
   | fluidanimate | 131072 | 0.00697 |
   | fluidanimate | 163840 | 0.00697 |
   | fluidanimate | 196608 | 0.00679 |
   | fluidanimate | 229376 | 0.00674 |
   | fluidanimate | 262144 |  0.0067 |
   | freqmine     |   orig |   0.002 |
   | freqmine     |   9472 | 0.00196 |
   | freqmine     |  18944 | 0.00198 |
   | freqmine     |  28416 | 0.00199 |
   | freqmine     |  37888 | 0.00191 |
   | freqmine     |  47360 | 0.00192 |
   | freqmine     |  56832 |   0.002 |
   | freqmine     |  66304 | 0.00199 |
   | freqmine     |  75776 |   0.002 |
   | swaptions    |   orig | 0.02065 |
   | swaptions    |  32768 | 0.01888 |
   | swaptions    |  65536 |  0.0152 |
   | swaptions    |  98304 | 0.01389 |
   | swaptions    | 131072 |  0.0124 |
   | swaptions    | 163840 | 0.01237 |
   | swaptions    | 196608 | 0.01238 |
   | swaptions    | 229376 | 0.01219 |
   | swaptions    | 262144 | 0.01221 |

8. Reduction for each program
   #+begin_src lisp :var in=energy-reduction
     (setf all nil)
     
     (mapc (lambda-bind ((bench evals energy))
             (let ((b (make-keyword (string-upcase bench))))
               (if (assoc b all)
                   (push energy (cdr (assoc b all)))
                   (push (list b energy) all))))
           (cdr in))
     
     (remove nil
       (mapcar (lambda-bind ((bench . energies))
                 (let ((top (extremum energies #'<))
                       (bot (extremum energies #'>)))
                   (unless (zerop top)
                     (list bench (float (/ (- top bot) top))))))
               all))
   #+end_src

   #+RESULTS:
   | :SWAPTIONS    |   -0.6940114 |
   | :BZIP2        | -0.103448264 |
   | :FREQMINE     | -0.047120474 |
   | :FLUIDANIMATE | -0.095522426 |
   |---------------+--------------|
   |               |  -0.23502564 |
   #+TBLFM: @5$2=vmean(@1..@-1)

*** auxiliary
#+begin_src lisp :package optimize
(defun ingest (file)
  (with-open-file (in file :direction :input)
    (apply #'mapcar #'cons
           (loop :for line = (read-line in nil nil) :while line
              :collect (let ((line (regex-replace-all "," line " ")))
                         (read-from-string (format nil "(~a)" line)))))))

(ingest "results/energy-final-metrics/swaptions-orig-0.csv")
#+end_src

** TODO measure runtime of evolved programs
** TODO Complete test suites for some benchmarks
Ideally at least one or two from each group of benchmark programs.
Spec has some open-source programs (e.g., perl, gcc, bzip) which could
be good candidates.  Eric will look into some better tests for PARSEC
programs.

** DONE distributed sub-pop by compiler flags
Just an exploratory test to see how this performs.  Running with bzip2.

1. Build five seeds with different optimization levels.
   #+begin_src sh
     mkdir -p bzip2-dist
     for flag in O0 O1 O2 O3 Os;do
         mgmt clean bzip2
         mgmt compile bzip2 -F -$flag
         mv benchmarks/bzip2/bzip2.s bzip2-dist/$flag.s
     done
   #+end_src

2. Build the =optimize= executable s.t. five of them can fit into 120G
   of memory, and with the zeromq library loaded.
   #+begin_src sh
     export LISP_STACK=$((24 * 1024))
     make clean && make LL=iolib
   #+end_src

3. We'll now run one optimization process for each flag.  See [[file:src/io.lisp][io.lisp]]
   and [[file:src/by-flag.lisp][by-flag.lisp]] for specifics, basically the actions for each
   process are as follows.
   - load up an original individual with the given compiler flag
   - mark the genome of the original
   - we mark the genomes of the individuals in each population, so we
     can later track code generated using different compiler flags
     through sub-populations
   - at every period, each subpopulation picks one individual with a
     tournament, and sends that individual to another subpopulation at
     random.

   Kick off the five optimization threads.
   #+begin_src sh
     for flag in O0 O1 O2 O3 Os;do
         optimize results/bzip2-dist/$flag.s bzip2 -t 12 -w sh-runner/work \
             -r results/bzip2-dist \
             -e "(defvar flag '$flag)" -c src/by-flag.lisp &
     done   
   #+end_src

*** analysis of results
**** fittest individuals
Collate all of the results files into one large text file.
#+begin_src lisp
  (in-package :optimize)
  (defvar flag 'O0)
  (load "src/by-flag.lisp")
  
  ;; read a file
  (defun ingest (file)
    (with-open-file (in file :direction :input)
      (loop :for line = (read-line in nil nil) :while line
         :collect (read-from-string (format nil "(~a)" line)))))
  
  (defvar base "results/distributed-runs/bzip2")
  
  ;; read and combine all files
  (with-open-file (out (format nil "~a/all-stats.txt" base) :direction :output)
    (format out "~{~{~a~^ ~}~^~%~}~%"
            (mapcan (lambda-bind ((flag . stats))
                      (mapcar [{cons flag} {subseq _ 0 2}] stats))
                    (mapcar (lambda-bind ((flag . port))
                              (cons flag (ingest (format nil "~a/~a/stats.txt"
                                                         base flag))))
                            ports))))
#+end_src

Graph the improvement over time.
#+headers: :results silent
#+headers: :file etc/data/by-flag-fitness-by-time.svg
#+begin_src gnuplot :var data="results/distributed-runs/bzip2/all-stats.txt"
  # set logscale x
  # set logscale y
  plot "< grep O0 $data" u 2:3 w l title 'O0', \
       "< grep O1 $data" u 2:3 w l title 'O1', \
       "< grep O2 $data" u 2:3 w l title 'O2', \
       "< grep O3 $data" u 2:3 w l title 'O3', \
       "< grep OS $data" u 2:3 w l title 'Os'
#+end_src

**** makeup of bests in each population
For each of the bests, write out their percent makeup.

1. best numbers
   #+begin_src sh
     for flag in O0 O1 O2 O3 OS;do
         ls results/distributed-runs/bzip2/$flag/best-* \
             |sed 's/^.*best-//;s/.store//'|sort -n \
             > results/distributed-runs/bzip2/$flag.eval-nums
     done
   #+end_src

2. For each flag, write out the composition of the best at each point
   #+begin_src lisp
     (in-package :optimize)
     (defvar flag 'O0)
     (load "src/by-flag.lisp")
     
     ;; read a file
     (defvar flags (mapcar #'car ports))
     (defvar base "results/distributed-runs/bzip2")
     
     (defun flag-compositions (flag)
       (with-open-file (in (format nil "~a/~a.eval-nums" base flag))
         (loop :for line = (read-line in nil nil) :while line :collect
            (let* ((number (read-from-string line))
                   (best (restore (format nil "~a/~a/best-~d.store"
                                          base flag number))))
              (cons (cons :evals number)
                    (counts (mapcar [#'second {assoc :flag}] (genome best))
                            :frac t))))))
     
     (defun compositions-to-file (flag comp)
       (with-open-file (out (format nil "~a/~a.composition" base flag)
                            :direction :output)
         (format out "~{~{~f~^ ~}~^~%~}~%"
                 (mapcar (lambda (list)
                           (cons (aget :evals list)
                                 (mapcar (lambda (it) (or it 0))
                                         (mapcar {aget _ list} flags))))
                         comp))))
     
     (mapc (lambda (flag) (compositions-to-file flag (flag-compositions flag))) flags)
   #+end_src

3. Plot these compositions
   #+headers: :results silent
   #+begin_src gnuplot :file /tmp/by-flag-sub-pop-comps.svg
     # data files
     O0="results/distributed-runs/bzip2/O0.composition"
     O1="results/distributed-runs/bzip2/O1.composition"
     O2="results/distributed-runs/bzip2/O2.composition"
     O3="results/distributed-runs/bzip2/O3.composition"
     Os="results/distributed-runs/bzip2/OS.composition"
     
     # multiplot layout
     set tmargin 1.5
     set bmargin 0
     set lmargin 5
     set rmargin 5
     set multiplot layout 5,1 title "\nComposition of Sub-populations\n"
     
     # graph-wide options
     set style fill solid
     set style histogram rowstacked
     set style data histograms
     # set xrange [0:1024]
     unset title
     unset ytics
     unset xtics
     
     # plots
     set key above
     set ylabel 'O0'
     plot O0 u 2 t 'O0', '' u 3 t 'O1', '' u 4 t 'O2', '' u 5 t 'O3', '' u 6 t 'Os'
     
     set tmargin 0
     unset key
     set ylabel 'O1'
     plot O1 u 2, '' u 3, '' u 4, '' u 5, '' u 6
     set ylabel 'O2'
     plot O2 u 2, '' u 3, '' u 4, '' u 5, '' u 6
     set ylabel 'O3'
     plot O3 u 2, '' u 3, '' u 4, '' u 5, '' u 6
     set ylabel 'Os'
     plot Os u 2:xtic(1), '' u 3, '' u 4, '' u 5, '' u 6
     
     unset multiplot
   #+end_src

*** with better composition reporting and new naturalization
#+begin_src lisp
  (in-package :optimize)
  (defvar flag 'O0)
  (load "src/by-flag.lisp")
  
  ;; read a file
  (defvar flags (mapcar #'car ports))
  (defvar base "results/distributed-runs/bzip2")
  
  (defun collect (it)
    (let ((totals (mapcar {cons _ 0} flags)))
      (mapcar (lambda (line)
                (mapcar (lambda (f)
                          (incf (cdr (assoc f totals))
                                (or (cdr (assoc f line)) 0)))
                        flags)) it)
      (let ((total (reduce #'+ (mapcar #'cdr totals))))
        (mapcar (lambda-bind ((obj . cnt)) (cons obj (/ cnt total))) totals))))
  
  (defun cmps-for-flag (flag)
    (with-open-file (out (format nil "~a/~a.composition" base flag)
                         :direction :output :if-exists :supersede)
      ((lambda (cmps)
         (format out "~{~{~f~^ ~}~^~%~}~%"
                 (mapcar #'cons
                         (mapcar #'car cmps)
                         (mapcar [{mapcar #'cdr} #'collect #'cdr] cmps))))
       (read-from-string
        (format nil "(~a)" (file-to-string
                            (format nil "~a/~a/cmp.lisp" base flag)))))))
  
  (mapc #'cmps-for-flag flags)
#+end_src

** CANCELED Build a Memory Fitness Function
We could use the "bubble" and the "reporter" from [[#mars2011bubble]].
Measuring the values of HW counters against the bubble could give us
coefficients for a memory linear model.

** CANCELED Find Warehouse Compute Benchmark Applications
** TODO Run Experiments
| benchmark    | Energy UVA | Energy UNM | Memory UVA | Memory UNM |
|--------------+------------+------------+------------+------------|
| PARSEC       |            |            |            |            |
|--------------+------------+------------+------------+------------|
| blackscholes |            |            |            |            |
| bodytrack    |            |            |            |            |
| facesim      |            |            |            |            |
| ferret       |            |            |            |            |
| fluidanimate |            |            |            |            |
| freqmine     |            |            |            |            |
| raytrace     |            |            |            |            |
| swaptions    |            |            |            |            |
| vips         |            |            |            |            |
| x264         |            |            |            |            |
|--------------+------------+------------+------------+------------|
| SPEC         |            |            |            |            |
|--------------+------------+------------+------------+------------|
|              |            |            |            |            |
|--------------+------------+------------+------------+------------|
| Warehouse    |            |            |            |            |
|--------------+------------+------------+------------+------------|

** TODO Baseline Runs
** TODO Build table results table
** TODO Analyze Optimizations
** TODO Build optimization Taxonomy
* Issues [3/4]
** TODO Running out of memory
#+begin_quote
I would suggest that your first stop should be the unglamorous ROOM
and its more exotic cousin

  (sb-vm::memory-usage :print-spaces t :print-summary nil)

to figure out just what kind of objects you are leaking. If the answer
is "instances", then

  (sb-vm:instance-usage :dynamic :top-n 100)

will tell you what kind of instances.

...which will make tracking down the actual leak that much easier.
#+end_quote

*** analysis                                                         :ATTACH:
    :PROPERTIES:
    :Attachments: beginning.types end.types
    :ID:       a6f9dac5-5d20-4d33-b96b-c14b6e2f70c1
    :END:
#+begin_src sh
    join <(sort /tmp/beginning.types ) <(sort /tmp/end.types ) \
        |awk '{print ($4-$2), $1}'|sort -rn|head -20
#+end_src

#+RESULTS:
| 1204160 | SB-IMPL::STRING-OUTPUT-STREAM             |
|  546880 | SB-FORMAT::FORMAT-DIRECTIVE               |
|  453760 | PATHNAME                                  |
|  207936 | SB-SYS:FD-STREAM                          |
|   89088 | SB-IMPL::STRING-INPUT-STREAM              |
|   61600 | SB-ALIEN-INTERNALS:ALIEN-VALUE            |
|   18880 | ASM-PERF                                  |
|   13632 | RESTART                                   |
|    6816 | SIMPLE-ERROR                              |
|    3072 | SB-DI::COMPILED-CODE-LOCATION             |
|    2560 | SB-DI::COMPILED-FRAME                     |
|    1344 | SB-PCL::FAST-METHOD-CALL                  |
|    1280 | SB-DI::BOGUS-DEBUG-FUN                    |
|    1008 | SB-C::COMPILED-DEBUG-FUN                  |
|     768 | SB-PCL::SLOT-INFO                         |
|     720 | SB-PCL::CACHE                             |
|     512 | SB-MOP:STANDARD-EFFECTIVE-SLOT-DEFINITION |
|     384 | SB-PCL::WRAPPER                           |
|     224 | SB-PCL::CACHING                           |
|     160 | SB-C::DEBUG-SOURCE                        |

*** h264 analysis
**** breakdown of total space
#+begin_src sh
  instances(){
      cat etc/data/h264-memory/$1  \
          | sed -n '/Breakdown for dynamic space:/,/space total./p' \
          | grep -v "Breakdown for dynamic space" \
          | grep -v "space total." \
          | sed 's/^ *//;s/,//g;s/bytes for \+[0-9]\+ //;s/ objects.//' \
          | awk '{print $2, $1}' \
          | sort; }
  
  join <(instances 0.txt) <(instances 14506.txt) \
      |awk '{print ($2-$4), $1}'|sort -rn|head
#+end_src

#+RESULTS:
| 430292496 | cons                          |
|  70620400 | simple-character-string       |
|  25039664 | instance                      |
|  18791088 | code                          |
|  14332816 | simple-vector                 |
|   3639552 | symbol                        |
|   3160016 | simple-array-unsigned-byte-64 |
|   1842688 | simple-base-string            |
|   1217472 | closure                       |
|   1206144 | simple-bit-vector             |

**** dynamic types
#+begin_src sh
  instances(){
      cat etc/data/h264-memory/$1  \
          | sed -n '/Top 200 dynamic/,$p' \
          | grep -v "Dynamic instance total" \
          | grep -v "Other types" \
          | sed 's/^ *//;s/: / /;s/ bytes,//;s/ objects//' \
          | sort; }
  
  join <(instances 0.txt) <(instances 14506.txt) \
      |awk '{print ($4-$2), $1}'|sort -rn|head
#+end_src

#+RESULTS:
| 240 | SB-C::FILE-INFO    |
| 224 | TWO-WAY-STREAM     |
| 192 | SB-C::SOURCE-INFO  |
|  64 | SB-C::NLX-INFO     |
|  61 | SB-THREAD:MUTEX    |
|  50 | SB-C::REF          |
|  48 | SB-C::IR2-NLX-INFO |
|  44 | SB-C::VOP          |
|  41 | SB-C::LVAR         |
|  35 | SB-C::CTRAN        |

** DONE SB-INT:BUG
This was caused by running the room function, should no longer be a
problem.

Caused by =room= and either =sb-ext:dynamic-space-size= or
=sb-vm::DYNAMIC-USAGE= and either =sb-vm::memory-usage= or
=sb-vm:instance-usage=.

: debugger invoked on a SB-INT:BUG in thread
: #<THREAD RUNNING {1007754DD3}>:
:     failed AVER:
:       (OR (EQL (ROOM-INFO-LENGTH INFO) (1+ #)) (FLOATP OBJ)
:           (SIMPLE-ARRAY-NIL-P OBJ))
:   This is probably a bug in SBCL itself. (Alternatively, SBCL might have been
:   corrupted by bad user code, e.g. by an undefined Lisp operation like
:   (FMAKUNBOUND 'COMPILE), or by stray pointers from alien code or from unsafe
:   Lisp code; or there might be a bug in the OS or hardware that SBCL is running
:   on.) If it seems to be a bug in SBCL itself, the maintainers would like to
:   know about it. Bug reports are welcome on the SBCL mailing lists, which you
:   can find at <http://sbcl.sourceforge.net/>.
: 

: debugger invoked on a SB-INT:BUG in thread
: #<THREAD RUNNING {100A5A6473}>:
:     failed AVER: (< I 2)
:   This is probably a bug in SBCL itself. (Alternatively, SBCL might have been
:   corrupted by bad user code, e.g. by an undefined Lisp operation like
:   (FMAKUNBOUND 'COMPILE), or by stray pointers from alien code or from unsafe
:   Lisp code; or there might be a bug in the OS or hardware that SBCL is running
:   on.) If it seems to be a bug in SBCL itself, the maintainers would like to
:   know about it. Bug reports are welcome on the SBCL mailing lists, which you
:   can find at <http://sbcl.sourceforge.net/>.

With a handler case printing out the errors
: 2013.06.09.23.55.43: track-memory error: #<SB-INT:BUG "~@<failed AVER: ~2I~_~A~:>" {101A9E7843}>

: 2013.06.09.23.42.54: track-memory error: #<TYPE-ERROR expected-type: INTEGER
:                                  datum: #<invalid object #x3200000039>>

** DONE Some multi-proc multi-threaded errors
Wrapped the socket communication functions in error handlers.
: debugger invoked on a POLL-ERROR in thread
: #<THREAD RUNNING {10462AA273}>:
:   Error caught while polling file descriptor 12: Unknown error
: 2013.06.07.15.34.19: checkpoint after 60672 fitness evaluations

** DONE new code errors
Reverted use of =delete= in the eviction function.

: debugger invoked on a SB-KERNEL:INDEX-TOO-LARGE-ERROR in thread
: #<THREAD RUNNING {1045C77673}>:
:   The index 512 is too large.

: debugger invoked on a SB-KERNEL:INDEX-TOO-LARGE-ERROR in thread
: #<THREAD RUNNING {1045C754A3}>:
:   The index 511 is too large.

: debugger invoked on a SB-KERNEL:INDEX-TOO-LARGE-ERROR in thread
: #<THREAD RUNNING {103AE21713}>:  
:   The index 511 is too large.

: debugger invoked on a SIMPLE-ERROR in thread
: #<THREAD RUNNING {1045C779B3}>:
:   There is no applicable method for the generic function
:     #<STANDARD-GENERIC-FUNCTION FITNESS (1)>
:   when called with arguments
:     (NIL).

: debugger invoked on a SB-KERNEL:BOUNDING-INDICES-BAD-ERROR in thread
: #<THREAD RUNNING {10C7778993}>:
:   The bounding indices 0 and 513 are bad for a sequence of length 512.
: See also:
:   The ANSI Standard, Glossary entry for "bounding index designator"
:   The ANSI Standard, writeup for Issue SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR

* Setup and Reproduction Instructions
The following instructions may be used to reproduce and expand upon
these results.

** Installing PARSEC
The PARSEC homepage is at http://parsec.cs.princeton.edu/.  Download
the [[http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz][PARSEC tarball]], and unpack it into the benchmarks sub-directory of
this repository.

** Using the Graphite Virtual Machine
*** Virtual Machine Setup

1. We will create a Qemu virtual machine and install the Debian 5.0.9
   specifically =debian-5010-i386-netinst.iso= from
   http://cdimage.debian.org/debian-cd/6.0.6/amd64/iso-cd/debian-6.0.6-amd64-netinst.iso
   #+begin_src sh
     # create the disk
     qemu-img create -f qcow2 tune.qcow 24G
     # install the operating system
     qemu-system-x86_64 tune.qcow -cdrom debian-5010-i386-netinst.iso -boot d
   #+end_src

2. Walk through the instillation dialog, we'll set the following
   values.
   | hostname            | tune          |
   | version             | stable        |
   | root password       | password      |
   | new user full name  | Francis Bacon |
   | new user login name | bacon         |
   | new user password   | password      |

   When it comes time to select which packages to install, deselect
   "Graphical desktop environment" and do select "SSH server".

   After the setup completes reboot and log in as root.

4. Now install the Graphite and Parsec dependencies,
   #+begin_src sh
     # Graphite dependencies
     apt-get update
     apt-get install build-essential libtool automake autoconf autotools-dev
     apt-get install libboost1.42-dev libboost-filesystem1.42-dev libboost-system1.42-dev
     apt-get install git-core
     # Parsec dependencies
     apt-get install gettext yasm
     # So the bacon user can have sudo
     apt-get install sudo
   #+end_src
   give the =bacon= user =sudo= permissions,
   #+begin_src sh
     echo "bacon   ALL=(ALL) ALL" >> /etc/sudoers
   #+end_src
   and shutdown the machine.
   #+begin_src sh
     shutdown -h now
   #+end_src

5. Start up the virtual machine with network access so we can connect
   with ssh -- allowing copy-paste from the local machine, use of a
   normal terminal, and other niceties.
   #+begin_src sh
     qemu-kvm -hda tune.qcow -nographic -cdrom data/debian-5010-amd64-netinst.iso \
         -m 1G -net nic -net user,hostfwd=tcp:127.0.0.1:2222-:22 -daemonize
   #+end_src

*** Running Graphite
1. Log into =tune= as =bacon=.
   #+begin_src sh
     ssh -p 2222 bacon@localhost
   #+end_src
   and install Graphite following these instructions from
   https://github.com/mit-carbon/Graphite/wiki/Getting-Started, after
   getting version 53271 of pin from [[http://www.pintool.org/downloads.html][PIN|downloads]] decompress it to
   =~/pin=.  Then set this location into =~/graphite/Makefile.config=.
   #+begin_src sh
     cat <<EOF > ~/graphite/Makefile.config
     # where Pin is uzipped to
     PIN_HOME = /home/bacon/pin
     EOF
   #+end_src
   Run =make= to build Graphite.

2. Confirm that the build was successful by running the following
   which should exit successfully.
   #+begin_src sh
     make ping_pong_app_test CORES=16 PROCS=2
   #+end_src

3. At this point the virtual machine is usable for running
   applications through Graphite and collecting metrics.  If modeling
   power consumption then one more dependency must be installed.
   McPAT is available at http://www.hpl.hp.com/research/mcpat/.  The
   tarball should be downloaded to the virtual machine and unpacked
   into the home directory.
   #+begin_src sh
     cd ~/archives/
     wget http://www.hpl.hp.com/research/mcpat/mcpat0.8_r274.tar.gz
     cd ~
     tar xzf archives/mcpat0.8_r274.tar.g
     sudo apt-get install g++-multilib libc6-dev-i386
     mv mcpat0.8_r274/ mcpat/
     cd mcpat/
     make
   #+end_src

   To enable power modeling, in =~/graphite/carbon_sim.cfg= set
   =enable_power_modeling= to =true=.
   #+begin_src sh
     sed 's/enable_power_modeling = false/enable_power_modeling = true/' \
         -i ~/graphite/carbon_sim.cfg
   #+end_src

*** Running the PARSEC benchmark with Graphite
Much of these instructions are adopted from [[https://github.com/mit-carbon/Graphite/wiki/Adding-and-Running-Applications#Running an application from the PARSEC benchmark suite][Running an application
from the PARSEC benchmark suite]].

1. To install Parsec in the virtual machine for use with Graphite,
   download and unpack the tarball from
   http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz.
   #+begin_src sh
     cd ~/archives/
     wget http://parsec.cs.princeton.edu/download/3.0/parsec-3.0.tar.gz
     cd ~/graphite/tests/
     # this may take some time...
     tar xzf archives/parsec-3.0.tar.gz
   #+end_src

2. Add Parsec and Graphite environment variables to =~/.profile=.
   #+begin_src sh
     cat <<EOF >> ~/.profile
     export PIN_HOME=$HOME/pin
     export GRAPHITE_HOME=$HOME/graphite
     export PARSEC_HOME=$GRAPHITE_HOME/tests/parsec-2.1
     export PARSECDIR=$PARSEC_HOME
     export xxPARSECDIRxx=$PARSECDIR
     source $PARSEC_HOME/env.sh
     EOF
   #+end_src

3. We can largely just follow the instructions on the [[https://github.com/mit-carbon/Graphite/wiki/Adding-and-Running-Applications#Running%20an%20application%20from%20the%20PARSEC%20benchmark%20suite][graphite wiki]].

4. Then from the Graphite home directory, set the =PARSEC_HOME=
   variable in the file =tests/Makefile.parsec= to point to the source
   of the PARSEC source tree.
   #+begin_src sh
     cd ${GRAPHITE_HOME}
     sed -i "s/^PARSEC_HOME \?= \?.*$/PARSEC_HOME=$(echo $PARSEC_HOME|sed 's/\//\\\//g')/" \
         tests/Makefile.parsec
   #+end_src

   Run =make parsec_setup= and =make [app]_parsec= to simulate the
   =[app]= with Graphite using the parameters specified in
   =tests/Makefile.parsec=. E.g.,
   #+begin_src sh
     make blackscholes_parsec
   #+end_src

*** Running a Simple Fast Fourier Transform (FFT)
The FFT benchmark has higher memory requirements than the simple
ping-pong test, so for this we'll have to increase the memory of the
VM by passing the =-m 1G= flag to the call to =qemu-kvm=.
#+begin_src sh
  ./src/run-vm tune.qcow 2222
#+end_src

This should run for a while and complete with output that looks like
the following.
: FFT with Blocking Transpose
:    65536 Complex Doubles
:    64 Processors
:    65536 Cache lines
:    16 Byte line size
:    4096 Bytes per page
:
:
:                  PROCESS STATISTICS
:             Computation      Transpose     Transpose
:  Proc          Time            Time        Fraction
:     0          79869664       27878043       0.34904
:
:                  TIMING INFORMATION
: Start time                        : 1333389980838004
: Initialization finish time        : 1333390099558235
: Overall finish time               : 1333390179427899
: Total time with initialization    :        198589895
: Total time without initialization :         79869664
: Overall transpose time            :         27878043
: Overall transpose fraction        :          0.34904

*** Evolving a Population of Variants
This experimental setup is held in a git directory available from
http://gitweb.adaptive.cs.unm.edu/optimization.git for anonymous git
access with the following.
: git clone http://gitweb.adaptive.cs.unm.edu/optimization.git

Using the scripts in file:src/host-test and file:src/guest-test,
the experimental harness in file:src/optimize.lisp and the [[http://gitweb.adaptive.cs.unm.edu/software-evolution.git][software
evolution]] framework it is possible to evolve populations of variants
of the original FFT program to optimize for certain execution
properties.  The following instructions describe how to evolve a
population of variant programs using multiple VM back ends for
parallel fitness evaluation.

1. Copy the file:src/guest-test script into the =/home/bacon/bin/=
   on the virtual machine.  Power off the virtual machine before
   performing the next step.
   #+begin_src sh
     scp src/guest-test -P 2222 bacon@localhost:bin/
     ssh -p 2222 root@localhost poweroff
   #+end_src

2. We will use the file:src/limit.c test harness to protect our
   evolutionary process from the sometimes aberrant behavior of the
   test execution shell scripts and the evolved variants which they
   execute.  Compile both host and guest versions of this script and
   place them for use by the host and guest test scripts.
   #+begin_src sh
     # host limit harness
     gcc -o src/limit src/limit.c
     # guest limit harness
     scp src/limit.c -P 2222 bacon@localhost:bin/
     ssh -p 2222 bacon@localhost gcc -o bin/limit bin/limit.c
     ssh -p 2222 root@localhost poweroff
   #+end_src

3. The current version of file:src/host-test assumes that all
   virtual machines are running on =localhost= and that they are
   placed behind different port numbers.  To setup multiple VMs on
   your local machine saving their port numbers to the
   file:src/REMOTES file (as required by file:src/host-test) follow
   the steps in [[#running-overlays][Running overlays]].

4. Since ssh is apparently /very/ sensitive to widely readable public
   keys, be sure to fix access permission for file:data/id_rsa which
   may not be preserved by git.
   #+begin_src sh
     chmod 700 data/id_rsa
   #+end_src

5. Change into the =src/= directory and fire up a Common Lisp
   interpreter (SBCL version 1.0.55 was used to prepare these
   instructions).  Ensure that the [[http://gitweb.adaptive.cs.unm.edu/software-evolution.git][software evolution]] framework is
   installed and load the file:src/optimize.lisp file into your lisp
   session.  To test that things your test scripts, virtual machines,
   and lisp install are all working correctly evaluate the original
   FFT program and ensure that it's fitness is equal to 1.
   #+begin_src lisp
     (require 'software-evolution)
     (in-package 'software-evolution)
     (load "optimize.lisp")
     (unless (neutral-p (evaluate *orig*))
       (error "Something is wrong, debug your script/lisp setup."))
   #+end_src

6. If everything appears to be working as expected, then a population
   of 100 variants can be evolved to minimize execution time by
   running the following.  See file:src/optimize.lisp to change the
   default configuration of things like population size, tournament
   size, and the features optimized for.

*** Running overlays
  :PROPERTIES:
  :shebang:  #!/bin/sh
  :CUSTOM_ID: running-overlays
  :END:
Qemu overlays create lightweight disk images based off of a starting
disk image which can be used to store diffs from the original, and to
run multiple instances of an original.

We'll use overlays to parallelize the fitness evaluation in our
genetic algorithm.

To create some number of overlay images run;
#+begin_src sh :tangle src/create-vms
  pushd overlays/
  for i in $(seq 46);do
      j=$(printf "%0.2d" i);
      if [ ! -f "$j.qcow" ];then
          qemu-img create -b ../tune.qcow -f qcow2 "$j.qcow"
      fi
  done
  popd
#+end_src

To run all overlays daemonized;
#+begin_src sh :tangle src/startup-vms
  remotes=""
  pushd overlays/
  for i in $(seq 46);do
      I=$(printf "%0.2d" i);
      ../src/run-vm "$I.qcow" "30$I"
      remotes="$remotes \"30$I\""
  done
  popd
  cat <<EOF > src/REMOTES
  #!/bin/sh
  REMOTES=($remotes)
  EOF
#+end_src

*** Running LLVM/Clang and clang-mutate
1. Log into =tune= as =root=

2. Install subversion.
   #+begin_src sh
     apt-get install subversion
   #+end_src

3. Install the llvm/clang from SVN.
   #+begin_src sh
     cd /usr/local/src/
     svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
     cd llvm/tools/
     svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
     cd ../
     ./configure && make install && make clean
   #+end_src

4. Install [[https://github.com/eschulte/clang-mutate][clang-mutate]] from git.
   #+begin_src sh
     cd /usr/local/src/
     git clone git://github.com/eschulte/clang-mutate.git
     cd clang-mutate
     make install && make clean
   #+end_src

