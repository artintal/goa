Optimization Notes  -*- mode:org; org-attach-directory:"etc/data/" -*-
#+Options: ^:{}
#+Property: header-args:gnuplot :results silent

* Work Plan
:   train energy    memory       benchmarks       baselines       write
:     models      fitness func       |         (Rinard, O2 O3)      |
:      |              |              |                |             |
:      |              v              |                v             |
:      +--> begin evolutionary <-----+------------> apply           |
:                 runs                            baselines         |
:                  |                                  |             |
:                  v                                  v             |
:            lists of bests --------------> compare performance     |
:                  |                        against baselines       |
:                  v                                  |             |
:             minimize and                            |             |
:               analyze                               |   table     |
:                  |                                  |  results    |
:                  |                                  +------------>|
:        +---------+----------+                                     |
:        |                    |                                     |
:        v                    v                                     |
:    taxonomy of      compare to known                              |
:   optimizations       techniques             find loop            |
:        |                    |               perforation, etc...   |
:        |                    +------------------------------------>|
:        |                                                          |
:        |                                                          |
:        |                                      taxonomy            |
:        +--------------------------------------------------------->|
:                                                                   |
:                                                                   |
:                                                                   v
:                                                                finished
:                                                                 paper

** Optional Additional Topics
- Breeders :: apply the Breeders Equation to analyze the relations
              between software traits and predict directions of
              software evolution

- Pareto :: return a Pareto frontier of solutions as a result of
            optimization rather than a single individual

- MCMC :: our mutation operations are nearly MCMC compliant already,
          with some small changes we should be able to implement MCMC
          as a search strategy

* Notes
** Benchmarks
Perhaps these Fortran programs would make a suitable addition to our
benchmark suites.  http://www.polyhedron.com/MFL6VW74649

*** PARSEC applications
| Program      | Language   | parallel      | test difficulty | working set | communication |
|--------------+------------+---------------+-----------------+-------------+---------------|
| blackscholes | C/CPP      | data parallel | easy            | small       | negligible    |
| bodytrack    | CPP        | pipeline      | hard            |             |               |
| facesim      | C/CPP      | data parallel | hard            |             |               |
| ferret       | C          | pipeline      | hard            | huge        | very much     |
| fluidanimate | CPP        | data parallel | easy            | large       | some          |
| freqmine     | CPP/OpenMP | data parallel | medium          | huge        | some          |
| raytrace     | C/OpenGL   | data parallel |                 | large       | little        |
| swaptions    | CPP        | data parallel |                 | medium      | little        |
| vips         | C          | data parallel | medium (image)  | medium      | some          |
| x264         | C          | pipeline      | medium (video)  | medium      | very          |

*** SPEC
| program        |
|----------------|
| 400.perlbench  |
| 401.bzip2      |
| 403.gcc        |
| 410.bwaves     |
| 416.gamess     |
| 429.mcf        |
| 433.milc       |
| 434.zeusmp     |
| 435.gromacs    |
| 436.cactusADM  |
| 437.leslie3d   |
| 444.namd       |
| 445.gobmk      |
| 447.dealII     |
| 450.soplex     |
| 453.povray     |
| 454.calculix   |
| 456.hmmer      |
| 458.sjeng      |
| 459.GemsFDTD   |
| 462.libquantum |
| 464.h264ref    |
| 465.tonto      |
| 470.lbm        |
| 471.omnetpp    |
| 473.astar      |
| 481.wrf        |
| 482.sphinx3    |
| 483.xalancbmk  |
| 998.specrand   |
| 999.specrand   |

* Tasks [31/38]
** DONE select GP parameters
| selection tournament |   2 |
| eviction tournament  |   2 |
| crossover            | 3/5 |

*** Table
Need two tables of the improvement as a percent at a given number of
fitness evaluations, by crossover, tourny, and eviction.

We *do* want tournaments of size two both on eviction and selection.

#+begin_src sh
  base=results/gp-params
  for bench in x264;do
      for cross in 0.2 0.4 0.6 0.8;do
          for rep in 0 1 2 3;do
              file=$base/$bench-c$cross-r$rep
              if [ -f $file/stats.txt ];then
                  start=$(grep ORIG-FITNESS $file/optimize.log \
                      |sed 's/^.*\. //;s/)).*$//')
                  end=$(head -61 $file/stats.txt|tail -1|cut -d' ' -f2)
                  echo "$file $(echo "(($start - $end)/$start)*100"|bc -l)"
                  # echo "$file $(tail -1 $file/stats.txt|cut -d' ' -f1)"
              fi
          done
      done
  done
#+end_src

#+RESULTS:
| results/gp-params/x264-c0.6-r3 | 15.055468005597977 |
| results/gp-params/x264-c0.2-r3 | 15.095939171673221 |
| results/gp-params/x264-c0.8-r3 |  15.23522967271784 |
| results/gp-params/x264-c0.2-r2 | 15.245963612659393 |
| results/gp-params/x264-c0.6-r2 |  15.28315001478055 |
| results/gp-params/x264-c0.4-r3 | 15.284961789633671 |
| results/gp-params/x264-c0.8-r2 | 15.305170053447231 |
| results/gp-params/x264-c0.4-r2 | 15.578787461510336 |
| results/gp-params/x264-c0.4-r1 |   16.8862646075101 |
| results/gp-params/x264-c0.2-r0 | 17.149267976059324 |
| results/gp-params/x264-c0.8-r1 | 17.172081138982314 |
| results/gp-params/x264-c0.6-r1 | 17.182486717773283 |
| results/gp-params/x264-c0.4-r0 | 17.274885933561873 |
| results/gp-params/x264-c0.6-r0 | 17.452098002102243 |
| results/gp-params/x264-c0.2-r1 | 18.086150187927704 |
| results/gp-params/x264-c0.8-r0 | 18.425964590022513 |

swaptions
| results/gp-params/swaptions-c0.2-r2 |                    |
| results/gp-params/swaptions-c0.6-r2 |                    |
| results/gp-params/swaptions-c0.4-r3 | 11.969286152016883 |
| results/gp-params/swaptions-c0.4-r2 | 12.847726517149553 |
| results/gp-params/swaptions-c0.4-r0 | 14.291349092674388 |
| results/gp-params/swaptions-c0.6-r3 | 15.035733608146852 |
| results/gp-params/swaptions-c0.2-r3 |  16.05657201981774 |
| results/gp-params/swaptions-c0.8-r2 | 16.383240996762535 |
| results/gp-params/swaptions-c0.4-r1 | 16.818833092694163 |
| results/gp-params/swaptions-c0.2-r0 | 19.288385568704324 |
| results/gp-params/swaptions-c0.2-r1 | 20.153073881194803 |
| results/gp-params/swaptions-c0.6-r1 | 22.155126850713373 |
| results/gp-params/swaptions-c0.8-r3 |  22.31364741334099 |
| results/gp-params/swaptions-c0.8-r1 |  23.91813876744032 |
| results/gp-params/swaptions-c0.8-r0 | 24.111429642036452 |
| results/gp-params/swaptions-c0.6-r0 | 34.707868447016494 |

*** Graphs
#+begin_src gnuplot
  set title 'multiple swaptions runs w/varied GP parameters'
  set ylabel 'energy model'
  set xlabel 'fitness evaluations'
  set key outside below
  plot for [tourny in "1 2"] for [rep in "0 1"] for [cross in "0.2 0.5 0.8"] \
       "results/gp-params/x264-c".cross."-t".tourny."-".rep."/stats.txt" \
       using 1:2 with lines title "c:".cross." t:".tourny
#+end_src

#+RESULTS:

- first GP parameterization run
  [[file:etc/data/mut-params.svg]]

*** runs
**** first run
first run
| mut | cross |
|-----+-------|
| 0.2 | 0.2   |
| 0.5 | 0.5   |
| 0.8 | 0.8   |

second run
|   mut | cross |
|-------+-------|
|  0.75 | 1/6   |
| 0.875 | 2/6   |
| 1.0   | 3/6   |
|       | 4/6   |

#+begin_src sh
  for bench in swaptions;do
      for mut in 0.2 0.5 0.8;do
          for cross in 0.2 0.5 0.8;do
              optimize benchmarks/$bench/$bench.s $bench -l g++ -f -lpthread \
                  -c $cross -m $mut -w sh-runner/work -t 4 \
                  -r results/mut-cross/$bench-$mut-$cross &
          done
      done
  done
#+end_src

**** third run
Started <2013-07-05 Fri 09:50> on real and complex.
#+begin_src sh
  for cross in 0.2 0.4 0.6 0.8;do
      for rep in 0 1 2 3;do
          optimize benchmarks/x264/x264.s x264 -f "-lm -lpthread" -c $cross -T 2 -w sh-runner/work -t 2 -r results/gp-params/x264-c$cross-r$rep&
          optimize benchmarks/swaptions/swaptions.s swaptions -l g++ -f -lpthread -c $cross -T 2 -w sh-runner/work -t 2 -r results/gp-params/swaptions-c$cross-r$rep&
      done
  done
#+end_src

** DONE find minimal input sizes for each program
Need to estimate the variance in our energy predictions, which are
linear combinations of HW counters, from variance in the HW counters.

So that we can reduce test input sizes (which increases variance in
the HW counters) until the variance in our predictions become too high
to accurately guide our GP process.

The goal is to balance faster running time with fitness function
accuracy.

Best.
| Program      | size   |  stdev | runtime(s) |
|--------------+--------+--------+------------|
| blackscholes | medium |     1% |      0.761 |
| bodytrack    | small  |   1.8% |      0.522 |
| facesim      | NA     |     2% |       12.6 |
| ferret       | small  |  3.16% |      0.537 |
| fluidanimate | small  |   3.9% |      0.567 |
| freqmine     | small  |  5.68% |      2.492 |
| swaptions    | small  |  1.11% |      0.386 |
| vips         | small  |        |      0.643 |
| x264         | small  | 22.78% |      2.210 |

Suggested Starting.
| Program      | size   |  stdev | runtime(s) |
|--------------+--------+--------+------------|
| blackscholes | large  |  0.62% |        3.1 |
| bodytrack    | medium |  0.79% |        1.6 |
| facesim      | NA ‡   |  1.63% |       12.7 |
| ferret       | medium |  4.28% |        1.6 |
| fluidanimate | medium |  3.74% |        1.3 |
| freqmine     | medium |  7.24% |       24.0 |
| swaptions †  | medium | 16.01% |        1.6 |
| vips         | medium |        |      1.960 |
| x264         | medium | 21.29% |       15.5 |

† This one recorded on my laptop using the Intel power model, *not* on
  the AMD machine (because they're busy w/other runs).

‡ Every input for facesim is the same.

*** results
**** runtime
#+begin_src sh :var dir="etc/hw-counters/amd"
  mean(){
      awk '{for (i=1; i<=NF; i++)
        {
            if($i ~ /[0-9.]/){sum[i] += $i; count[i]++}
                if(i == 1){ line = sum[i]/count[i] }
                else{ line = line " " sum[i]/count[i]}
        }
        print line
    }'; }
  
  runtime(){
      cat $dir/$1|sed -n "/$2/,/^$/p" \
          |grep seconds|cut -d, -f1|mean|tail -1; }
  
  echo "benchmark tiny small medium large"  
  for file in $(ls $dir);do
      echo -n "$(basename $file .csv) "
      for size in tiny small medium large;do
          echo -n "$(runtime $file $size) "
      done
      echo ""
  done
#+end_src

#+name: bagel-seconds
| benchmark    |       tiny |     small |   medium |   large |
|--------------+------------+-----------+----------+---------|
| blackscholes | 0.00139599 | 0.0883597 | 0.351268 | 1.41977 |
| swaptions    | 0.00175334 |  0.385808 |  1.55343 | 6.17976 |
| x264         | 0.00305646 |   1.09651 |  8.38398 | 23.9957 |

#+name: amd-seconds
| benchmark    |       tiny |    small |   medium |   large |
|--------------+------------+----------+----------+---------|
| blackscholes | 0.00352846 | 0.189511 | 0.761738 | 3.09857 |
| bodytrack    |   0.174888 | 0.522415 |  1.63459 | 5.70894 |
| facesim      |    12.6936 |   12.681 |  12.6683 | 12.7136 |
| ferret       |  0.0458039 | 0.537712 |  1.61332 | 6.40102 |
| fluidanimate |   0.144897 | 0.567231 |  1.28914 | 3.95435 |
| freqmine     |  0.0285459 |  2.49217 |  24.0017 |  24.795 |
| x264         | 0.00833094 |  2.21065 |  15.5278 | 24.1012 |

**** % stdev
#+begin_src sh :var data=amd-hw-counter-results :var dir="etc/hw-counters/bagel"
  echo "bench test tiny small medium large"
  for file in $(ls $dir);do
      bench=$(basename $file .csv)
      echo -n "$bench "
      echo "$data"|sed -n "/$bench/,/^ *$/p"|tail -n +3|awk '{print $5}'|tr '\n' ' '
      echo ""
  done
#+end_src

#+RESULTS:
| bench     |      test |     tiny |      small |     medium |      large |
|-----------+-----------+----------+------------+------------+------------|
| swaptions | 15.87082% | 100.593% | 1.1134541% | 16.012053% | 9.3935995% |

#+name: amd-stdev
| bench        |        tiny |      small |      medium |       large |
|--------------+-------------+------------+-------------+-------------|
| blackscholes |          NA | 3.6077793% |  1.0085185% |  0.6235825% |
| bodytrack    |  6.6038585% | 1.8731365% | 0.79246277% | 0.36703333% |
| facesim      |  2.0346885% | 1.7943326% |  1.6388873% |  2.2005231% |
| ferret       |  15.474045% | 3.1627514% |  4.2882867% |   6.599503% |
| fluidanimate |   2.767907% |  3.991133% |  3.7424817% |    3.79219% |
| freqmine     |  24.301325% |  5.685626% |   7.238976% |  20.959188% |
| x264         | -2777.5918% | 22.787048% |   21.29686% |          NA |

**** orig
#+name: bagel-hw-counter-results
#+begin_src sh :results scalar :cache yes
  for csv in etc/hw-counters/bagel/*.csv;do
      echo ""
      echo $(basename $csv)
      ./bin/model-variance $csv -m intel-sandybridge-power-model -c seconds
  done
#+end_src

#+RESULTS[b7edce96d073074cd1caf43f0eddafe702e9a55e]: bagel-hw-counter-results
: 
: blackscholes.csv
: size          mean    variance      stdev      percent number   seconds
: test     101.34776   5189949.0    2278.146   2247.8503%   30   0.001131961
: tiny      58.55405    2629.377    51.27745   87.572845%   30   .0013959858
: small    61.804443   10.808836   3.2876794    5.319487%   30   0.088359706
: medium   61.189903     1.13793    1.066738   1.7433236%   30    0.35126838
: large    61.117825     94.6876    9.730755   15.921304%   30     1.4197656
: 
: swaptions.csv
: size          mean    variance      stdev      percent number   seconds
: test     56.033386     79.0847    8.892958    15.87082%   30   .0012815109
: tiny     61.596092   3839.2625    61.96178   100.59369%   30   .0017533372
: small     69.04976   0.5911108  0.76883733   1.1134541%   30    0.38580817
: medium   68.728546   121.10673    11.00485   16.012053%   30     1.5534309
: large      68.8817   41.866997    6.470471   9.3935995%   30     6.1797624
: 
: x264.csv
: size          mean    variance      stdev      percent number   seconds
: test    106.706635   1417427.9   1190.5577   1115.7299%   30   .0011979803
: tiny      81.34485   131861.45   363.12732    446.4048%   30   .0030564559
: small     89.97716   50.139324   7.0809126    7.869678%   30     1.0965112
: medium     91.9157   38.264412   6.1858234   6.7298875%   30      8.383977
: large     91.98692   88.095535    9.385922    10.20354%   30     23.995699

#+name: amd-hw-counter-results
: 
: blackscholes.csv
: size          mean    variance      stdev      percent number   seconds
: test            NA          NA           NA   NA
: tiny            NA          NA           NA   NA
: small     357.0362    165.9222   12.881079   3.6077793%   60    0.18951055
: medium   356.22357   12.906636   3.5925808   1.0085185%   60     0.7617375
: large    357.14096   4.9598336   2.2270684   0.6235825%   60     3.0985744
: 
: bodytrack.csv
: size          mean    variance      stdev      percent number   seconds
: test     309.27975    596.6946   24.427332   7.8981347%   60     0.1501637
: tiny     315.05032   432.86795    20.80548   6.6038585%   60    0.17488833
: small     327.8489   37.712585   6.1410575   1.8731365%   60    0.52241516
: medium    329.5972   6.8222046   2.6119351  0.79246277%   60     1.6345919
: large    331.02692   1.4761741    1.214979  0.36703333%   60      5.708939
: 
: facesim.csv
: size          mean    variance      stdev      percent number   seconds
: test     291.57385   283853.75    532.7793   182.72534%   59   0.009274179
: tiny     329.34906    44.90644   6.7012267   2.0346885%   60     12.693625
: small     330.0119   35.064297    5.921511   1.7943326%   60     12.681024
: medium   330.07697   29.263657   5.4095893   1.6388873%   60     12.668328
: large    330.79834    52.98813   7.2792945   2.2005231%   60     12.713568
: 
: ferret.csv
: size          mean    variance      stdev      percent number   seconds
: test     340.60904   61361.477    247.7125    72.72634%  120   0.017328184
: tiny     329.80637   2604.5085   51.034386   15.474045%  120     0.0458039
: small     320.4449  102.715706   10.134875   3.1627514%  120    0.53771156
: medium   330.07324   200.34949   14.154487   4.2882867%  120      1.613321
: large     336.8951   494.32428   22.233404    6.599503%  120     6.4010215
: 
: fluidanimate.csv
: size          mean    variance      stdev      percent number   seconds
: test      309.9557   25271.879   158.97131   51.288403%  120    0.02404317
: tiny     323.55173    80.20296     8.95561    2.767907%  120     0.1448967
: small    333.66986     177.348   13.317207    3.991133%  120    0.56723106
: medium   326.40076   149.21817   12.215489   3.7424817%  120     1.2891381
: large    327.16507   153.92673   12.406721     3.79219%  120     3.9543471
: 
: freqmine.csv
: size          mean    variance      stdev      percent number   seconds
: test     217.23047   632.64526   25.152441    11.57869%   60    0.10334522
: tiny     280.90414    4659.896    68.26343   24.301325%   60   0.028545866
: small    236.09837   180.19493   13.423671    5.685626%   60     2.4921725
: medium   215.25912   242.81606   15.582556    7.238976%   60     24.001656
: large     225.5313   2234.4082   47.269527   20.959188%   60     24.795027
: 
: x264.csv
: size          mean    variance      stdev      percent number   seconds
: test            NA          NA           NA   NA
: tiny    -150.84175  17554156.0    4189.768  -2777.5918%   49   .0083309375
: small    214.00151   2377.9888   48.764626   22.787048%   60     2.2106462
: medium   202.39847   1857.9993   43.104515    21.29686%   60     15.527754
: large           NA          NA           NA   NA

#+begin_src sh :var data=amd-hw-counter-results :results scalar
  echo "$data" > /tmp/to-gnuplot
#+end_src

#+begin_src gnuplot :file /tmp/variance-by-input-size.tex
  set term tikz size 3in,2.5in
  set key above
  set title 'power model variance by run time'
  set xlabel 'runtime in seconds'
  set ylabel 'percent model variance'
  set logscale y
  set logscale x
  plot for [bench in "blackscholes bodytrack facesim ferret fluidanimate freqmine x264"] \
       "<(sed -n '/".bench."/,/^ *$/p' /tmp/to-gnuplot|grep '[0-9]')" \
       u 6:4 title bench
#+end_src

#+RESULTS:
[[file:/tmp/variance-by-input-size.tex]]

*** DONE Step by step process for input minimization
    DEADLINE: <2013-06-11 Tue>
    :PROPERTIES:
    :shebang:  #!/bin/bash
    :END:
For every benchmark program, test a range of input sizes until we find
the smallest input which results in stable HW counters.

The HW counters are definitely correlated, so we should use something
like the following.
http://wikipedia.org/wiki/Variance#Sum_of_correlated_variables

1. Perform 30 runs collecting counters for each size.
   (use the =hw-counters-by-size= script)
   
   #+begin_src sh
     # no options required for a default run
     ./bin/hw-counters-by-size
   #+end_src

2. Using the architecture-specific model, calculate the variance of
   the model for each size based on the counter values for that size.
   (use the =model-variance= executable)

   For example, to look at the variance by run for blackscholes.
   #+begin_src sh
     ./bin/model-variance etc/hw-counters/intel/blackscholes.csv -c seconds
   #+end_src

   #+RESULTS:
   | size   |      mean |  variance |    percent | number |      seconds |
   | test   | 101.34776 | 5189949.0 | 5120931.0% |     30 |  0.001131961 |
   | tiny   |  58.55405 |  2629.377 | 4490.5127% |     30 | 0.0013959858 |
   | small  | 61.804443 | 10.808836 |  17.48877% |     30 |  0.088359706 |
   | medium | 61.189903 |   1.13793 | 1.8596696% |     30 |   0.35126838 |
   | large  | 61.117825 |   94.6876 | 154.92633% |     30 |    1.4197656 |

4. For each benchmark, pick the smallest (read: fastest) input size
   which keeps variance within some fraction of the output.  I'm not
   100% sure how to do this, and surprisingly some programs have
   increased variance on the larger input sizes, e.g., swaptions on my
   laptop.  Maybe 30 runs at each size are not enough?

   #+begin_src sh
     ./bin/model-variance etc/hw-counters/intel/swaptions.csv -c seconds
   #+end_src

   #+RESULTS:
   | size   |      mean |  variance |     percent | number |      seconds |
   | test   | 56.033386 |   79.0847 |  141.13853% |     30 | 0.0012815109 |
   | tiny   | 61.596092 | 3839.2625 |  6232.9644% |     30 | 0.0017533372 |
   | small  |  69.04976 | 0.5911108 | 0.85606503% |     30 |   0.38580817 |
   | medium | 68.728546 | 121.10673 |  176.21022% |     30 |    1.5534309 |
   | large  |   68.8817 | 41.866997 |  60.781013% |     30 |    6.1797624 |

*** Specific benchmarks
why do some benchmarks always show high variance

**** ferret
***** with 120 runs
#+begin_src sh
  ./bin/model-variance etc/hw-counters/amd/ferret.csv -c seconds -m amd-opteron-power-model
#+end_src

#+RESULTS:
| size   |      mean |   variance |     stdev |    percent | number |     seconds |
|--------+-----------+------------+-----------+------------+--------+-------------|
| test   | 340.60904 |  61361.477 |  247.7125 |  72.72634% |    120 | 0.017328184 |
| tiny   | 329.80637 |  2604.5085 | 51.034386 | 15.474045% |    120 |   0.0458039 |
| small  |  320.4449 | 102.715706 | 10.134875 | 3.1627514% |    120 |  0.53771156 |
| medium | 330.07324 |  200.34949 | 14.154487 | 4.2882867% |    120 |    1.613321 |
| large  |  336.8951 |  494.32428 | 22.233404 |  6.599503% |    120 |   6.4010215 |

***** looking at particular counters
#+begin_src sh
  ./bin/model-variance etc/hw-counters/amd/ferret.csv -p -c seconds -m amd-opteron-power-model -s medium
#+end_src

#+RESULTS:
| counter          |         mean |          variance |       stdev |    percent |
| EXIT             |          0.0 |               0.0 |         0.0 |         NA |
| ERROR            |          0.0 |               0.0 |         0.0 |         NA |
| CYCLES           | 6054498000.0 |     2.2756214e+16 | 150851630.0 |   2.491563 |
| INSTRUCTIONS     | 5482641000.0 | 375754470000000.0 |  19384388.0 | 0.35355932 |
| R533F00          | 1780987600.0 |  97827350000000.0 |   9890771.0 | 0.55535316 |
| CACHE-REFERENCES | 1860805500.0 |  63416836000000.0 |   7963469.0 |  0.4279582 |
| CACHE-MISSES     |   1018128.44 |     14369304000.0 |   119872.03 |  11.773763 |
| SECONDS          |     1.613321 |        0.40135768 |  0.63352793 |  39.268562 |

**** more runs -- vips (should build on real)
**** more runs -- fluidanimate
Performing *more* runs at each size of fluidanimate on real.
#+begin_src sh
  ./bin/model-variance etc/hw-counters/amd/fluidanimate.csv -c seconds -m amd-opteron-power-model
#+end_src

#+RESULTS:
| size   |      mean |  variance |     stdev |    percent | number |    seconds |
|--------+-----------+-----------+-----------+------------+--------+------------|
| test   |  309.9557 | 25271.879 | 158.97131 | 51.288403% |    120 | 0.02404317 |
| tiny   | 323.55173 |  80.20296 |   8.95561 |  2.767907% |    120 |  0.1448967 |
| small  | 333.66986 |   177.348 | 13.317207 |  3.991133% |    120 | 0.56723106 |
| medium | 326.40076 | 149.21817 | 12.215489 | 3.7424817% |    120 |  1.2891381 |
| large  | 327.16507 | 153.92673 | 12.406721 |   3.79219% |    120 |  3.9543471 |

**** by counter -- swaptions large
** DONE Build all benchmarks to ASM [10/10]
*** parsec
**** DONE Blackscholes
**** DONE bodytrack
Here is the command I used to make an executable from the assembly file.
    (note :/nfs/adaptive/stharding/tmp/parsec-3.0 should be replaced with
    the path to parsec)
: g++ -L /nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/bodytrack/obj/amd64-linux.gcc/FlexImageLib/.libs/  -L /nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/bodytrack/obj/amd64-linux.gcc/TrackingBenchmark/threads/.libs/ bodytrack.s -o bodytrack -lflex -lpthread -lthreads
And here is the command I used to make the asm file (note the relative
    paths. Might be a good idea to change to absolute paths) see the
    management script to make the cpp file (also, I think it is necessary
    to build with the parsec management script first so that the config.h
    file will be generated.)
:
: g++ -DHAVE_CONFIG_H -I. -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/bodytrack/src/FlexImageLib -I.. -O3 -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions  -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -fexceptions  -MT FlexImage.lo -MD -MP -MF ../../obj/amd64-linux.gcc/FlexImageLib/.deps/FlexImage.Plo -I ../../obj/amd64-linux.gcc/ -L ../../obj/amd64-linux.gcc/FlexImageLib/.libs/ -I ../../../../libs/tbblib/src/include/ -L../../../../libs/tbblib/src/include/ -L ../../obj/amd64-linux.gcc/TrackingBenchmark/threads/.libs/ -S tst.cpp -o bodytrack.s -lflex -lpthread -lthreads

**** DONE facesim
To make ASM file:
first in the directory <path to parsec>/pkgs/apps/facesim/src/Benchmarks/facesim/:
: cat FACE_DRIVER.cpp FACE_LANDMARK_OPTIMIZATION_GOAL.cpp FACE_OPTIMIZATION.cpp LANDMARK_PROXIMITY_OPTIMIZATION.cpp main.cpp >all.cpp
then:
: g++ -O3 -w -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions -static-libgcc -pthread -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -fexceptions -DENABLE_PTHREADS -DUSE_ALAMERE_TASKQ -DNDEBUG -I../../../obj/amd64-linux.gcc/TaskQ/include -L../../../obj/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib ../../../obj/amd64-linux.gcc/TaskQ/lib/taskQ.o -S all.cpp -lPhysBAM -xW -lm

To build the executable:
: g++ -L../../../obj/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib ../../../obj/amd64-linux.gcc/TaskQ/lib/taskQ.o all.s -o facesim -pthread -lPhysBAM -xW -lm

**** DONE ferret
UPDATE: The problem was that the order of the -L arguments in mgmt was bad.
It caused the libjpeg.a from /usr/lib to be loaded but that was the wrong
version. Putting that -L last makes ferret build correctly

========================================================

UPDATE: when trying to run the executable you get the following message:
`Wrong JPEG library version: library is 80, caller expects 70'
I will investigate this and update

========================================================

To make the .S file:
First build with the parsec build tool
   (NOTE: this will fail unless you edit the makefiles in the gsl lib src directory.
   you must remove `doc' from SUBDIRS in both makefiles for gsl to build)
   Then, in the directory: <path to parsec>/pkgs/apps/ferret/obj/amd64-linux.gcc/benchmark
   (change /nfs/adaptive/stharding/tmp/parsec-3.0/ to your path to parsec):

   : gcc -w -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/ferret/src/include/ -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/libs/gsl/inst/amd64-linux.gcc/include -I/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/libjpeg/inst/amd64-linux.gcc/include  -O3 -g -funroll-loops -fprefetch-loop-arrays -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/gsl/inst/amd64-linux.gcc/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/libjpeg/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/ferret/inst/amd64-linux.gcc/lib/ -S ferret-pthreads.c -lrt -lcass -lgsl -lcassimage -lgslcblas -ljpeg -lstdc++ -lpthread -lm

To make the executable:
   : gcc -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/gsl/inst/amd64-linux.gcc/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/libjpeg/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/ferret/inst/amd64-linux.gcc/lib/ ferret-pthreads.s -o ferret -lrt -lcass -lgsl -lcassimage -lgslcblas -ljpeg -lstdc++ -lpthread -lm

NOTE: there are other versions of ferret that can be built. This is the one that is built
      by default when you do ./parsecmgmt -a build -p ferret

**** DONE fluidanimate
**** DONE freqmine
1. cat all .cpp files together
2. remove duplicates of
   : include "common.h"
3. remove the second duplicate of the =omp_get_max_threads()=

**** DONE raytrace
To make the .S file:
First build raytrace by using the parsec mgmt tool. Then in pkgs/apps/raytrace/src/MiniView:
: g++ -DTHIS_IS_CMAKE -I/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/mesa/inst/amd64-linux.gcc/include -O3 -g -funroll-loops -fprefetch-loop-arrays -fpermissive -fno-exceptions -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -fexceptions -fno-strict-aliasing -fno-align-labels -DNDEBUG -D_MM_NO_ALIGN_CHECK  -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/RTTL -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/RTTL/common -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/RTTL/BVH -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/SG -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/LRT/include -I/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/LRT -L/nfs/adaptive/stharding/tmp/parsec-3.0/bin/../pkgs/libs/mesa/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/libs/mesa/inst/amd64-linux.gcc/lib -L/nfs/adaptive/stharding/tmp/parsec-3.0/pkgs/apps/raytrace/obj/amd64-linux.gcc/lib -S rtview.cxx -rdynamic  -lglut -lGL -lGL -lGLU -lXmu -lXext -lXau -lX11 -ldl -lpthread -lstdc++ -lpthread -lrt -lglut -lGL -lGL -lGLU -lXmu -lXext -lXau -lX11 -ldl -lpthread -lstdc++ -lrt

To make the executable: (updated to remove excess flags)
: g++  -L ../../../../libs/mesa/inst/amd64-linux.gcc/lib  rtview.s -o rtview    ../../obj/amd64-linux.gcc/lib/libLRT.a ../../obj/amd64-linux.gcc/lib/libRTTL.a  -lglut  -lGL -lGLU -lXmu -lXext -lXau -lX11 -ldl -lpthread -lstdc++ -lrt -rdynamic

**** DONE swaptions
#+begin_src sh
  cat *.c* > swaptions.cpp
  g++ -S swaptions.cpp
  g++ swaptions.s -o swaptions2
#+end_src

**** DONE vips
     It turns out that the bulk of the computation is done in the library libvips.a so the solution described below is not very good.
     Instead, we separate libvips.a into two parts and generate an asm file for the part we intend to evolve. See bin/libvips.sh

     ------------------------------------------------------------------------------

     In the directory: <path to parsec>/parsec-3.0/pkgs/apps/vips/src/tools/iofuncs
     compile vips to assembly by:
     gcc -std=gnu99 -DHAVE_CONFIG_H -I. -I../../ -I../../libvips/include -DG_DISABLE_CAST_CHECKS -pthread -I ../../../../../libs/libxml2/inst/amd64-linux.gcc/include/libxml2 -I../../../../../libs/glib/inst/amd64-linux.gcc/lib/glib-2.0/include -I../../../../../libs/glib/inst/amd64-linux.gcc/include/glib-2.0/  -I../../../obj/amd64-linux.gcc/  -O3 -g -funroll-loops -fprefetch-loop-arrays -static-libgcc -Wl,--hash-style=both,--as-needed -DPARSEC_VERSION=3.0-beta-20120904 -L../../../inst/amd64-linux.gcc/lib/  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -DG_DISABLE_CAST_CHECKS -I../../../../../libs/libxml2/inst/amd64-linux.gcc/include/libxml2 -I../../../../../libs/glib/inst/amd64-linux.gcc/lib/glib-2.0/include -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/libxml2/inst/amd64-linux.gcc/lib -S vips.c  -lgobject-2.0 -lgthread-2.0 -pthread    -lvips   -lm  -lstdc++ -lxml2 -lgmodule-2.0 -ldl -lglib-2.0

     To make an executable:
     gcc -L../../../inst/amd64-linux.gcc/lib/  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -L/usr/lib64 -L/usr/lib  -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/zlib/inst/amd64-linux.gcc/lib -DG_DISABLE_CAST_CHECKS -L../../../../../libs/glib/inst/amd64-linux.gcc/lib -L../../../../../libs/libxml2/inst/amd64-linux.gcc/lib vips.s  -lgobject-2.0 -lgthread-2.0 -pthread    -lvips   -lm  -lstdc++ -lxml2 -lgmodule-2.0 -ldl -lglib-2.0
**** DONE x264
We're *not* using the hand-coded ASM.  Rather we just build entirely
from the C source.

Interestingly O3 and O2 both throw the following error (with the
latest GCC which supports the =--combine= flag).
: x264.c: In function ‘main’:
: x264.c:92: internal compiler error: in insert_into_preds_of_block, at tree-ssa-pre.c:3155
: Please submit a full bug report,
: with preprocessed source if appropriate.
: See <http://gcc.gnu.org/bugs.html> for instructions.

*** SPEC
**** 400.perlbench
**** 401.bzip2
**** 403.gcc
**** 410.bwaves
**** 416.gamess
**** 429.mcf
**** 433.milc
**** 434.zeusmp
**** 435.gromacs
**** 436.cactusADM
**** 437.leslie3d
**** 444.namd
**** 445.gobmk
**** 447.dealII
**** 450.soplex
**** 453.povray
**** 454.calculix
**** 456.hmmer
**** 458.sjeng
**** 459.GemsFDTD
**** 462.libquantum
**** 464.h264ref
**** 465.tonto
**** 470.lbm
**** 471.omnetpp
**** 473.astar
**** 481.wrf
**** 482.sphinx3
**** 483.xalancbmk
**** 998.specrand
**** 999.specrand
** DONE Select Energy Models [2/2]
\begin{align*}
  &\begin{aligned}
     power &= C_{const} + C_{ins} \times \frac{ins}{cyc} + C_{flops} \times \frac{flops}{cyc} \\
           &\qquad + C_{tca} \times \frac{tca}{cyc} + C_{mem} \times \frac{mem}{cyc}
   \end{aligned}\\
  &\begin{aligned}
     energy &= seconds \times power
   \end{aligned}
\end{align*}

| metric                 | perf              |
|------------------------+-------------------|
| cyc                    | cycles            |
| ins                    | instructions      |
| ops(AMD Opteron)       | r533f00           |
| ops(Intel Sandybridge) | r532010 + r538010 |
| tca                    | cache-references  |
| mem                    | cache-misses      |

*** Measuring required counters with =perf=
Not all counters are provided by default, so we need to use HW
specific raw event.  According to [[http://web.eece.maine.edu/~vweaver/projects/perf_events/faq.html#q2e][this faq]] to find the appropriate
code for the raw events grab [[http://perfmon2.sourceforge.net/][libpfm4]] from [[http://sourceforge.net/projects/perfmon2/files/][here]].  Then unpack the
files, build, and browse the available raw events with the following.

#+begin_src sh
  cd libpfm-4.3.0
  make
  cd example
  ./showevtinfo -E|less
#+end_src

The resulting hex value can then be passed to perf by prefixing it
with an "r".

*** DONE AMD energy model
: perf stat -e cycles,instructions,r533f00,cache-references,LLC-loads,LLC-stores -- command

*** DONE Intel energy model
: perf stat -e cycles,instructions,r532010,r538010,cache-references,LLC-loads,LLC-stores

** DONE Train Energy Models [8/8]
Both at UVA on Intel and at UNM on AMD.

*** DONE more inputs runs
- Running SPEC a few more times
  #+begin_src sh
    for gcc in 44 48;do
        for flag in O1 O2 O3 Os;do
            collect_model_data.py --spec-config=cx-$gcc-$flag 1  
            mv benchmarks.csv benchmarks-$gcc-$flag.csv
        done
    done
  #+end_src
- More sleep benchmarks
  #+begin_src sh :results scalar
    tmp=$(mktemp XXXXXXXX.csv)
    (
        head -1 etc/model-data/amd/sleep-benchmarks.csv
        for f in sleep-benchmarks parsec-and-spec spec-gcc44-03 spec-gcc44-0s;do
            grep -v time etc/model-data/amd/$f.csv
        done
    ) > $tmp
    ./bin/power-model.R $tmp
    rm -f $tmp
  #+end_src

#+RESULTS:
: 
: Call:
: glm(formula = watts ~ ipc + fpc + cpc + mpc)
: 
: Deviance Residuals: 
:      Min        1Q    Median        3Q       Max  
: -302.560    -0.957    12.061    25.842   127.359  
: 
: Coefficients:
:             Estimate Std. Error t value Pr(>|t|)    
: (Intercept)   394.74      25.67  15.379  < 2e-16 ***
: ipc           -83.68      28.81  -2.904  0.00419 ** 
: fpc            60.23      26.21   2.298  0.02282 *  
: cpc           -16.38     108.64  -0.151  0.88035    
: mpc         -4209.09    2168.56  -1.941  0.05398 .  
: ---
: Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
: 
: (Dispersion parameter for gaussian family taken to be 6046.141)
: 
:     Null deviance: 1171514  on 168  degrees of freedom
: Residual deviance:  991567  on 164  degrees of freedom
: AIC: 1958
: 
: Number of Fisher Scoring iterations: 2
: 
: performing cross-validation...
: using RMS error
: model error:   76.5980479663483 
: 10x cross-val: 0.964 x

*** DONE comparative effectiveness of our three models
1. original energy
2. power model
3. power model with included evolved individuals

#+name: energy-model-comparison
|              |   wall plug |    original |          new |    new power | new power | new power |
| program      | measurement |      energy |        power |    w/evolved |    joules | w/evo (j) |
|--------------+-------------+-------------+--------------+--------------+-----------+-----------|
| swaptions    |  6.88333e-4 |  1.03268e-3 | 9.8714811e-4 | 9.3214667e-4 | 3553.7332 |  3355.728 |
| bzip2        |  1.06667e-5 |  1.89788e-5 | 1.5615243e-5 | 1.7711784e-5 | 56.214874 | 63.762424 |
| freqmine     |  6.66667e-5 |  2.23895e-3 | 1.6509342e-3 | 2.0344936e-3 |  5943.363 |  7324.177 |
| fluidanimate |  2.44666e-4 |  3.68712e-4 | 3.6373519e-4 |   3.38953e-4 | 1309.4467 | 1220.2308 |
|--------------+-------------+-------------+--------------+--------------+-----------+-----------|
| correlation  |             | 0.038806602 |   0.23415537 |  0.034193274 |           |           |
#+TBLFM: $4=$6/(60 * 60 * 1000)::$5=$7/(60 * 60 * 1000)

#+begin_src lisp :var data=energy-model-comparison
  (defun covariance (a b)
    (/ (reduce #'+ (mapcar #'*
                           (mapcar {- _ (mean a)} a)
                           (mapcar {- _ (mean b)} b)))
       (- (length a) 1)))
  
  (defun correlation (a b)
    (/ (covariance a b)
       (sqrt (* (variance a) (variance b)))))
  
  (let* ((raw (mapcar {mapcar (lambda (n) (if (numberp n) n (read-from-string n)))}
                      (butlast (mapcar #'cdr (cddr data)))))
         (wall (mapcar #'first raw))
         (orig (mapcar #'second raw))
         (power (mapcar #'third raw))
         (power-plus (mapcar #'fourth raw)))
    (mapcar {correlation wall}
            (list orig power power-plus)))
#+end_src

*** DONE retrain the power models with evolved individuals
    :PROPERTIES:
    :results:  silent
    :END:
Use sampling used in [[#evolved-energy-consumption]], dump through objread
to get stats, combine those stats with watts-up output in
results/energy-final-metrics, combine *that* with original training
data, and re-train the model.

#+begin_src sh
  export PATH=bin/:$PATH
  
  for prog in $(find results/energy-final-metrics/ -type f -executable);do
      echo ""
      echo $prog
      watts=$(cat $prog*csv|grep -v time|awk 'FS="," {print $2}'|mean|tail -1)
      bench=$(echo $prog|sed 's/.*metrics.//;s/-.*$//')
      (
          run $bench $prog -p
          echo "$watts,watts"
      ) |tee $prog.stats
  done
#+end_src

Collect all of the stats into a single large csv file.
#+begin_src sh
  (
      echo "bench,watts,kwh,exit,error,cycles,instructions,r533f00,cache-references,cache-misses,seconds"
      for prog in $(find results/energy-final-metrics/ -type f -executable);do
          tail=$(cat $prog.stats|grep -v watts|grep -v "task-clock"|sed 's/,.*$//'|tr '\n' ','|sed 's/,$//')
          bench=$(echo $prog|sed 's/.*metrics.//;s/-.*$//')
          for i in $(seq 0 9);do
              echo "$bench,$(tail -1 $prog-$i.csv|awk -F, '{printf "%f,%f", $2, ($5 / 30)}'),$tail"
          done
      done|grep -v blackscholes
  ) > results/energy-final-metrics.csv
#+end_src

And convert the original stats to this format
#+begin_src sh
  cat results/energy-metrics/combined-benchmarks.csv \
      |tail -n +2 \
      |awk -F, '{ print $1,$4,$3,0,0,$5,$6,$7,$8,$9,$2 }' \
      |sed 's/ /,/g' >> results/energy-final-metrics.csv
#+end_src

Removing any duplicate rows (because R complains otherwise).
#+begin_src sh :var csv="results/energy-final-metrics.csv"
  head -1 $csv > /tmp/sorted.csv
  tail -n +2 $csv|sort -u > /tmp/sorted.csv
#+end_src

And now we can train the power model against this large csv file.
#+begin_src sh :results replace scalar
  ./bin/power-model.R /tmp/sorted.csv
#+end_src

#+RESULTS:
: 
: Call:
: lm(formula = metrics$watts ~ ipc + fpc + cpc + mpc)
: 
: Residuals:
:      Min       1Q   Median       3Q      Max 
: -304.913   -0.981    0.229    1.774   45.620 
: 
: Coefficients:
:              Estimate Std. Error t value Pr(>|t|)    
: (Intercept) 3.049e+02  5.073e+00  60.104   <2e-16 ***
: ipc         7.205e-06  1.264e-05   0.570    0.569    
: fpc         9.395e-07  1.166e-05   0.081    0.936    
: cpc         7.031e-06  9.429e-06   0.746    0.456    
: mpc         1.370e-05  3.043e-05   0.450    0.653    
: ---
: Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
: 
: Residual standard error: 39.3 on 404 degrees of freedom
:   (349 observations deleted due to missingness)
: Multiple R-squared:  0.08757,	Adjusted R-squared:  0.07854 
: F-statistic: 9.694 on 4 and 404 DF,  p-value: 1.704e-07
: 

*** constrain the model to pass through the origin
Cycles is a proxy for time, so 0 counters should imply 0 kwh.

*** CANCELED include last two benchmark programs [0/2]
    DEADLINE: <2013-06-11 Tue>
- [ ] x264 from parsec (compiled)
- [ ] dealII from SPEC

*** CANCELED compile both of these last two benchmark programs [0/0]
- [X] x264 from parsec (compiled)
- [ ] dealII from SPEC

**** DealII
This discussion looks to be relevant to our build problems.
http://gcc.gnu.org/bugzilla/show_bug.cgi?id=44416

See this discussion of how to use alternate sources.
http://www.spec.org/cpu2006/Docs/config.html#sectionIX

See the list of alternate sources by SPEC version.
http://www.spec.org/cpu2006/src.alt/

See the particular alternate source which must be applied for dealII
to compile.
http://gcc.gnu.org/bugzilla/attachment.cgi?id=20848
http://www.spec.org/cpu2006/src.alt/447.dealII.explicit_inclusion_of_cstring.cpu2006.v1.0.tar.bz2

The command lines work out to be roughly
#+begin_src sh
  wget http://gcc.gnu.org/bugzilla/attachment.cgi?id=20848
  mv attachment.cgi\?id\=20848 447.dealII.cstddef.cpu2006.v1.1.tar.bz2
  specbzip2 -dc 447.dealII.cstddef.cpu2006.v1.1.tar.bz2 | spectar -xf  -
  echo "ext = without" > configs/without.cfg
  runspec --action buildsetup -T base -c without -v 1 447.dealII
  cat <<EOF > configs/with.cfg
  ext = with
  447.dealII:
  srcalt = cstddef
  EOF
  runspec --action buildsetup -T base -c with -v 1 447.dealII -I
  # now the changes have been applied, to then use the updated version
  # run the following where complex.cfg is replaced with the config file
  # for your system
  runspec --action build -c complex.cfg -v 1 447.dealII -I
#+end_src

*** DONE AMD power model
#+begin_src sh :results replace scalar
  cat \
      <(
      cat etc/model-data/amd/parsec-and-spec.csv;
      cat etc/model-data/amd/sleep-benchmarks.csv \
          etc/model-data/amd/spec-gcc44-0{3,s}.csv|grep -v time) >/tmp/all.csv
  ./bin/power-model.R /tmp/all.csv
#+end_src

#+RESULTS:
: 
: Call:
: glm(formula = watts ~ ipc + fpc + cpc + mpc)
: 
: Deviance Residuals: 
:      Min        1Q    Median        3Q       Max  
: -298.577    -2.156    11.593    22.661   160.396  
: 
: Coefficients:
:             Estimate Std. Error t value Pr(>|t|)    
: (Intercept)   401.09      25.72  15.594  < 2e-16 ***
: ipc          -108.41      30.56  -3.547 0.000504 ***
: fpc            78.98      27.23   2.901 0.004216 ** 
: cpc            15.09     109.54   0.138 0.890593    
: mpc         -4008.71    2136.13  -1.877 0.062283 .  
: ---
: Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
: 
: (Dispersion parameter for gaussian family taken to be 6132.292)
: 
:     Null deviance: 1268965  on 174  degrees of freedom
: Residual deviance: 1042490  on 170  degrees of freedom
: AIC: 2029.8
: 
: Number of Fisher Scoring iterations: 2
: 
: performing cross-validation...
: using RMS error
: model error:   77.1821479392715 
: 10x cross-val: 0.931 x

*** DONE AMD Energy Model
| metric           | perf             | coefficient |
|------------------+------------------+-------------|
| cyc              | cycles           |   4.411e-14 |
| ins              | instructions     |   2.235e-15 |
| ops(AMD Opteron) | r533f00          |  -8.531e-16 |
| tca              | cache-references |  -1.256e-14 |
| mem              | cache-misses     |   3.679e-13 |

**** Collected raw data relating energy consumption to hw counters.
#+name: amd-energy-and-hw-metrics
| benchmark      | time |    kwh |         watts |        cycles |  instructions |       r533f00 | cache-references | cache-misses |
|----------------+------+--------+---------------+---------------+---------------+---------------+------------------+--------------|
| blackscholes   |  439 | 0.0405 | 333.007061503 |  963681322941 |  759844691381 |  440277963193 |     165728320541 |    140040400 |
| bodytrack      |  345 | 0.0325 |  339.41884058 |  733091005874 |  781067817081 |  405865777512 |     127287608572 |    245673468 |
| facesim        |  0.0 |    0.0 |           0.0 |      16560559 |      14789833 |       1693208 |          4697405 |        74581 |
| ferret         |  522 | 0.0507 | 350.532950192 | 1588471176139 | 1748909071671 |  508858865217 |     567858426857 |    100044775 |
| fluidanimate   |  650 | 0.0608 | 337.591076923 | 1433302012584 | 1677896998422 | 1002609778300 |     484568539692 |     21997404 |
| freqmine       |  849 | 0.0806 | 342.344051826 | 1848878873062 | 2450052339453 |      49431788 |     791028342362 |     66097064 |
| raytrace       |  378 | 0.0358 | 341.426190476 |  834912012589 | 1204834722923 |  646652063937 |     244447040716 |    841572881 |
| swaptions      |  580 |  0.054 | 335.989482759 | 1277170247920 | 1458456204847 |  613924489347 |     361402521432 |    150688646 |
| vips           |  233 | 0.0219 | 338.053218884 |  506403393629 |  770985463673 |  204387614153 |     143861054265 |    203743614 |
| sleep2         |    1 | 0.0001 |         325.0 |       1068673 |        628101 |          1790 |           238757 |         9261 |
| sleep5         |    4 | 0.0004 |       327.375 |       1069525 |        606630 |          1774 |           256435 |        10316 |
| sleep10        |    9 | 0.0008 | 326.233333333 |       1021646 |        626510 |          1721 |           247746 |        10388 |
| sleep30        |   29 | 0.0026 | 323.475862069 |       1019901 |        649767 |          1785 |           237688 |         9336 |
| sleep60        |   59 | 0.0052 | 321.937288136 |       1037259 |        618201 |          1769 |           229123 |         9201 |
| blackscholes   |  437 | 0.0405 | 334.313501144 |  962242554271 |  759823452448 |  440248110213 |     159457388792 |    129664715 |
| bodytrack      |  346 | 0.0323 | 336.672543353 |  733724456347 |  781057881137 |  405865621890 |     127240780364 |    193147096 |
| facesim        |  0.0 |    0.0 |           0.0 |      16043941 |      14867195 |       1688548 |          4719060 |        73992 |
| ferret         |  522 | 0.0503 | 347.481417625 | 1608827613673 | 1748979636562 |  508724194111 |     567547428624 |    101952537 |
| fluidanimate   |  649 | 0.0609 | 337.980585516 | 1438777004290 | 1677905068279 | 1003486864457 |     484679953040 |     21736128 |
| freqmine       |  848 | 0.0805 | 342.425707547 | 1843800403467 | 2450061993769 |      49425812 |     791415640031 |     66253490 |
| raytrace       |  377 | 0.0358 | 341.849867374 |  831780621631 | 1204809370390 |  646658574964 |     245001617881 |    937017963 |
| swaptions      |  578 | 0.0539 | 336.156747405 | 1274440983375 | 1458375779265 |  613619457154 |     362297763899 |     48489018 |
| vips           |  235 | 0.0221 | 338.945106383 |  497932290315 |  770623602908 |  203161466196 |     144316491452 |    206477267 |
| sleep2         |    1 |    0.0 |         325.3 |       1057931 |        621206 |          1792 |           232246 |         9312 |
| sleep5         |    4 | 0.0003 |         325.0 |       1061374 |        617416 |          1746 |           221495 |         9137 |
| sleep10        |    9 | 0.0008 | 324.377777778 |        956587 |        609894 |          1735 |           237629 |         9774 |
| sleep30        |   29 | 0.0026 | 323.289655172 |       1075075 |        644843 |          1736 |           228295 |         9522 |
| sleep60        |   59 | 0.0053 | 322.161016949 |       1116455 |        642621 |          1733 |           234232 |         9589 |
| blackscholes   |  439 | 0.0407 | 333.797266515 |  978537944311 |  759853135482 |  448108538602 |     159681951945 |    130110732 |
| bodytrack      |  345 | 0.0326 | 340.417971014 |  734430891707 |  781078301944 |  405901756994 |     127221390140 |    214104415 |
| facesim        |  0.0 |    0.0 |           0.0 |      15865765 |      14759180 |       1691132 |          4682768 |        73876 |
| 400.perlbench  |  172 | 0.0164 | 343.927325581 |  363205546396 |  673460255215 |     198103220 |     168940598894 |    448530688 |
| 401.bzip2      |  127 | 0.0121 |  341.48503937 |  280624033346 |  319812916322 |        268031 |     105223223290 |      6408514 |
| 403.gcc        |   24 | 0.0023 | 341.170833333 |   55270414187 |   52882913988 |     501470091 |      19001587893 |    137057463 |
| 410.bwaves     | 1930 | 0.1848 | 345.140725389 | 4237316105602 | 3340156118640 | 1608974718204 |     785753595114 |     86869305 |
| 416.gamess     |  259 | 0.0247 | 344.312741313 |  568989187150 | 1047126415135 |  404543004871 |     212818566730 |    122987990 |
| 429.mcf        |  996 | 0.0951 |  344.20060241 | 2117183253301 |  303695508258 |       4429256 |     122279702747 |     42132139 |
| 433.milc       |  616 | 0.0595 | 348.169967532 | 1361085107228 | 1181353371826 |  850005142260 |     211799352223 |     29960505 |
| 434.zeusmp     |  881 | 0.0839 | 343.000908059 | 1942840268672 | 1805419511735 | 1596582662098 |     407497075587 |     46809057 |
| 435.gromacs    |  859 | 0.0813 | 341.240861467 | 1891264738863 | 2160419213985 | 1734939474915 |     416863263346 |     60722123 |
| 436.cactusADM  | 1426 | 0.1357 | 343.065287518 | 3133609562731 | 2730087227455 | 2830219681072 |     649952731741 |     99446625 |
| 437.leslie3d   |  717 | 0.0693 | 348.251324965 | 1569704929576 | 1551526352154 | 1059334560787 |     321208209593 |     42223855 |
| 444.namd       |  708 | 0.0671 | 341.838700565 | 1556051397196 | 2257288024298 | 1682197205095 |     466800570445 |     30132681 |
| 445.gobmk      |  136 | 0.0129 | 341.908088235 |  299407520238 |  323819168201 |    1723948132 |     144389853031 |    639965759 |
| 450.soplex     |  302 | 0.0289 | 345.098675497 |  643362986038 |  358494728333 |  128977762038 |     102926641824 |     17581665 |
| 453.povray     |  324 | 0.0309 | 343.569135802 |  713862677233 |  945909381078 |  347548355646 |     279604811656 |   1312346898 |
| 454.calculix   | 1423 | 0.1354 | 342.999508082 | 3130626046436 | 6166081367888 | 3715717501412 |    1344503685294 |    201472325 |
| 456.hmmer      |  416 | 0.0398 | 345.001201923 |  915193135250 | 1878847157364 |   17603610038 |     284255339691 |     30323193 |
| 458.sjeng      |  906 | 0.0861 | 342.556622517 | 1996773046731 | 2200085290815 |       1221094 |     981587003984 |    455529921 |
| 459.GemsFDTD   |  882 | 0.0854 |  349.20521542 | 1925374860097 | 1566606447376 | 1173916753733 |     280276041570 |     43114955 |
| 462.libquantum |  972 | 0.0941 | 348.936419753 | 2096058789720 | 1856427541448 |    4331708084 |     643820893885 |     35091747 |
| 464.h264ref    |  939 | 0.0895 | 343.535463259 | 2056952424155 | 2426423692805 |    1438263416 |     512591933779 |    562704357 |
| 465.tonto      | 1571 | 0.1489 | 341.581667728 | 3471179796415 | 3147373470456 | 1734083749913 |     806146473044 |   1584069489 |
| 470.lbm        |  816 |  0.079 | 348.779901961 | 1797592416770 | 1261010132344 | 1219123374595 |     207620646064 |     29699997 |
| 471.omnetpp    |  542 | 0.0518 | 344.322693727 | 1156254727500 |  588222734645 |   60116420268 |     201985211961 |   2200652189 |
| 473.astar      |  423 | 0.0401 | 341.430023641 |  934367239164 |  815560161952 |     133140874 |     361211047283 |     20556701 |
| 481.wrf        |  0.0 |    0.0 |           0.0 |     593370968 |     711694385 |     107167259 |        154949631 |       161652 |
| 482.sphinx3    | 1181 | 0.1107 | 337.783149873 | 2595951183221 | 3349740098022 | 2190608682991 |     770495377859 |    202291716 |
| 998.specrand   |  0.0 |    0.0 |           0.0 |     350025649 |     563269510 |      20079782 |        161604673 |      1484586 |
| 999.specrand   |  0.0 |    0.0 |           0.0 |     362873259 |     563235015 |      20069938 |        161784725 |      1479227 |

**** Trained a linear model off of these counters
     :PROPERTIES:
     :eval:     no
     :END:
These two models were generated using the following.

#+begin_src sh
  power-model.R etc/data/combined-benchmarks.csv
#+end_src

kwh ~  cycles instructions fops cache.references cache.misses
|                  |   Estimate | Std. Error |      t |  value | Pr  |
|------------------+------------+------------+--------+--------+-----|
| (Intercept)      |  3.036e-04 |  7.203e-04 |  0.421 | 0.6751 |     |
| cycles           |  4.411e-14 |  1.069e-15 | 41.243 | <2e-16 | *** |
| instructions     |  2.235e-15 |  1.959e-15 |  1.141 | 0.2591 |     |
| fops             | -8.531e-16 |  1.292e-15 | -0.660 | 0.5119 |     |
| cache.references | -1.256e-14 |  6.340e-15 | -1.981 | 0.0527 | .   |
| cache.misses     |  3.679e-13 |  1.214e-12 |  0.303 | 0.7630 |     |

#+begin_src sh
  build_power_model.py --target=kwh \
    --model=cycles,instructions,flop,cache-references,cache-misses \
    etc/data/combined-benchmarks.csv
#+end_src

Modeling kwh
| cycles           |   4.4212e-14 |
| instructions     |  1.27494e-15 |
| flop             | -6.77546e-16 |
| cache-references | -8.60545e-15 |
| cache-misses     |  1.42351e-13 |
| constant         |  0.000410495 |

*** DONE Intel Energy Model
** DONE measure energy consumption of evolved programs
   DEADLINE: <2013-06-11 Tue>
   :PROPERTIES:
   :CUSTOM_ID: evolved-energy-consumption
   :END:
#+name: amd-results
| results/swaptions-all |
| results/bs-all        |
| results/bzip2-all     |
| results/freqmine-all  |
| results/fluid-all-2   |

1. For all finished runs, collect some of the best individuals and
   compile them to executables.
   #+begin_src sh :var dirs=amd-results
     for dir in $(echo "$dirs");do
         sample $dir 8|xargs -I{} objread {} -l {}.exe
     done
   #+end_src

2. Move all of the executables into a single results directory.
   #+begin_src sh :var dirs=amd-results
     mkdir -p results/best-energy-exes
     for dir in $(echo "$dirs");do
         base=$(basename $dir)
         for exe in $dir/best*exe;do
             mv $exe results/best-energy-exes/$base-$(basename $exe)
         done
     done
   #+end_src

3. Copy the originals into the results directory as well.
   #+begin_src sh
     for bench in blackscholes bzip2 fluidanimate freqmine swaptions;do
         mgmt clean $bench
         mgmt link $bench
         cp benchmarks/$bench/$bench results/best-energy-exes/$bench-orig
     done
   #+end_src

4. Normalize the names of the files in the results directory.

5. Ensure output exists for every benchmark
   #+begin_src sh
     for bench in blackscholes bzip2 fluidanimate freqmine swaptions;do
         mgmt output $bench -s large
     done
   #+end_src

6. Measure the energy consumption of each program in the results
   directory.
   #+begin_src sh
     dir=results/energy-metrics
     for bench in blackscholes bzip2 fluidanimate freqmine swaptions;do
         for exe in $dir/$bench-*;do
             for i in $(seq 0 9);do
                 echo -e "running $bench\t$exe\t$i"
                 sleep 10
                 wu.py -o $exe-$i.csv ttyUSB0 -- run $bench $exe -s large -r 20
             done
         done
     done
   #+end_src

7. Collect energy metrics for each program.
   #+name: energy-reduction
   #+begin_src sh :dir results/energy-final-metrics/
     mean(){
         awk '{
             for (i=1; i<=NF; i++)
             {
                 if($i ~ /[0-9.]/){sum[i] += $i; count[i]++}
                     if(i == 1){ line = sum[i]/count[i] }else{ line = line " " sum[i]/count[i]}
             }
             print line
         }'; }
     
     for prog in $(find ./ -perm 755);do
         echo "$(basename $prog|cut -d- -f1) $(basename $prog|cut -d- -f2) $(cat $prog*csv|grep -v time|cut -d, -f5|mean|tail -1)"
     done
   #+end_src

   #+RESULTS: energy-reduction
   | blackscholes |   orig |       0 |
   | blackscholes |  32768 |       0 |
   | blackscholes |  65536 |       0 |
   | blackscholes |  98304 |       0 |
   | blackscholes | 131072 |       0 |
   | blackscholes | 163840 |       0 |
   | blackscholes | 196608 |       0 |
   | blackscholes | 229376 |       0 |
   | blackscholes | 262144 |       0 |
   | bzip2        |   orig | 0.00032 |
   | bzip2        |  32768 |  0.0003 |
   | bzip2        |  65536 |  0.0003 |
   | bzip2        |  98304 |  0.0003 |
   | bzip2        | 131072 | 0.00029 |
   | bzip2        | 163840 |  0.0003 |
   | bzip2        | 196608 |  0.0003 |
   | bzip2        | 229376 |  0.0003 |
   | bzip2        | 262144 |  0.0003 |
   | fluidanimate |   orig | 0.00734 |
   | fluidanimate |  32768 | 0.00713 |
   | fluidanimate |  65536 | 0.00714 |
   | fluidanimate |  98304 | 0.00708 |
   | fluidanimate | 131072 | 0.00697 |
   | fluidanimate | 163840 | 0.00697 |
   | fluidanimate | 196608 | 0.00679 |
   | fluidanimate | 229376 | 0.00674 |
   | fluidanimate | 262144 |  0.0067 |
   | freqmine     |   orig |   0.002 |
   | freqmine     |   9472 | 0.00196 |
   | freqmine     |  18944 | 0.00198 |
   | freqmine     |  28416 | 0.00199 |
   | freqmine     |  37888 | 0.00191 |
   | freqmine     |  47360 | 0.00192 |
   | freqmine     |  56832 |   0.002 |
   | freqmine     |  66304 | 0.00199 |
   | freqmine     |  75776 |   0.002 |
   | swaptions    |   orig | 0.02065 |
   | swaptions    |  32768 | 0.01888 |
   | swaptions    |  65536 |  0.0152 |
   | swaptions    |  98304 | 0.01389 |
   | swaptions    | 131072 |  0.0124 |
   | swaptions    | 163840 | 0.01237 |
   | swaptions    | 196608 | 0.01238 |
   | swaptions    | 229376 | 0.01219 |
   | swaptions    | 262144 | 0.01221 |

8. Reduction for each program
   #+begin_src lisp :var in=energy-reduction
     (setf all nil)
     
     (mapc (lambda-bind ((bench evals energy))
             (let ((b (make-keyword (string-upcase bench))))
               (if (assoc b all)
                   (push energy (cdr (assoc b all)))
                   (push (list b energy) all))))
           (cdr in))
     
     (remove nil
       (mapcar (lambda-bind ((bench . energies))
                 (let ((top (extremum energies #'<))
                       (bot (extremum energies #'>)))
                   (unless (zerop top)
                     (list bench (float (/ (- top bot) top))))))
               all))
   #+end_src

   #+RESULTS:
   | :SWAPTIONS    |   -0.6940114 |
   | :BZIP2        | -0.103448264 |
   | :FREQMINE     | -0.047120474 |
   | :FLUIDANIMATE | -0.095522426 |
   |---------------+--------------|
   |               |  -0.23502564 |
   #+TBLFM: @5$2=vmean(@1..@-1)

*** auxiliary
#+begin_src lisp :package optimize
(defun ingest (file)
  (with-open-file (in file :direction :input)
    (apply #'mapcar #'cons
           (loop :for line = (read-line in nil nil) :while line
              :collect (let ((line (regex-replace-all "," line " ")))
                         (read-from-string (format nil "(~a)" line)))))))

(ingest "results/energy-final-metrics/swaptions-orig-0.csv")
#+end_src

** TODO Expanded test suites for some benchmarks
To ensure that our optimizations don't trample all over the non-tested
functionality, we should include expanded test suites for some
programs.

** DONE distributed sub-pop by compiler flags
Just an exploratory test to see how this performs.  Running with bzip2.

1. Build five seeds with different optimization levels.
   #+begin_src sh
     mkdir -p bzip2-dist
     for flag in O0 O1 O2 O3 Os;do
         mgmt clean bzip2
         mgmt compile bzip2 -F -$flag
         mv benchmarks/bzip2/bzip2.s bzip2-dist/$flag.s
     done
   #+end_src

2. Build the =optimize= executable s.t. five of them can fit into 120G
   of memory, and with the zeromq library loaded.
   #+begin_src sh
     export LISP_STACK=$((24 * 1024))
     make clean && make LL=iolib
   #+end_src

3. We'll now run one optimization process for each flag.  See [[file:src/io.lisp][io.lisp]]
   and [[file:src/by-flag.lisp][by-flag.lisp]] for specifics, basically the actions for each
   process are as follows.
   - load up an original individual with the given compiler flag
   - mark the genome of the original
   - we mark the genomes of the individuals in each population, so we
     can later track code generated using different compiler flags
     through sub-populations
   - at every period, each subpopulation picks one individual with a
     tournament, and sends that individual to another subpopulation at
     random.

   Kick off the five optimization threads.
   #+begin_src sh
     for flag in O0 O1 O2 O3 Os;do
         optimize results/bzip2-dist/$flag.s bzip2 -t 12 -w sh-runner/work \
             -r results/bzip2-dist \
             -e "(defvar flag '$flag)" -c src/by-flag.lisp &
     done   
   #+end_src

*** analysis of results
**** fittest individuals
Collate all of the results files into one large text file.
#+begin_src lisp
  (in-package :optimize)
  (defvar flag 'O0)
  (load "src/by-flag.lisp")
  
  ;; read a file
  (defun ingest (file)
    (with-open-file (in file :direction :input)
      (loop :for line = (read-line in nil nil) :while line
         :collect (read-from-string (format nil "(~a)" line)))))
  
  (defvar base "results/distributed-runs/bzip2")
  
  ;; read and combine all files
  (with-open-file (out (format nil "~a/all-stats.txt" base) :direction :output)
    (format out "~{~{~a~^ ~}~^~%~}~%"
            (mapcan (lambda-bind ((flag . stats))
                      (mapcar [{cons flag} {subseq _ 0 2}] stats))
                    (mapcar (lambda-bind ((flag . port))
                              (cons flag (ingest (format nil "~a/~a/stats.txt"
                                                         base flag))))
                            ports))))
#+end_src

Graph the improvement over time.
#+headers: :file etc/data/by-flag-fitness-by-time.svg
#+begin_src gnuplot :var data="results/distributed-runs/bzip2/all-stats.txt"
  # set logscale x
  # set logscale y
  plot "< grep O0 $data" u 2:3 w l title 'O0', \
       "< grep O1 $data" u 2:3 w l title 'O1', \
       "< grep O2 $data" u 2:3 w l title 'O2', \
       "< grep O3 $data" u 2:3 w l title 'O3', \
       "< grep OS $data" u 2:3 w l title 'Os'
#+end_src

**** makeup of bests in each population
For each of the bests, write out their percent makeup.

1. best numbers
   #+begin_src sh
     for flag in O0 O1 O2 O3 OS;do
         ls results/distributed-runs/bzip2/$flag/best-* \
             |sed 's/^.*best-//;s/.store//'|sort -n \
             > results/distributed-runs/bzip2/$flag.eval-nums
     done
   #+end_src

2. For each flag, write out the composition of the best at each point
   #+begin_src lisp
     (in-package :optimize)
     (defvar flag 'O0)
     (load "src/by-flag.lisp")
     
     ;; read a file
     (defvar flags (mapcar #'car ports))
     (defvar base "results/distributed-runs/bzip2")
     
     (defun flag-compositions (flag)
       (with-open-file (in (format nil "~a/~a.eval-nums" base flag))
         (loop :for line = (read-line in nil nil) :while line :collect
            (let* ((number (read-from-string line))
                   (best (restore (format nil "~a/~a/best-~d.store"
                                          base flag number))))
              (cons (cons :evals number)
                    (counts (mapcar [#'second {assoc :flag}] (genome best))
                            :frac t))))))
     
     (defun compositions-to-file (flag comp)
       (with-open-file (out (format nil "~a/~a.composition" base flag)
                            :direction :output)
         (format out "~{~{~f~^ ~}~^~%~}~%"
                 (mapcar (lambda (list)
                           (cons (aget :evals list)
                                 (mapcar (lambda (it) (or it 0))
                                         (mapcar {aget _ list} flags))))
                         comp))))
     
     (mapc (lambda (flag) (compositions-to-file flag (flag-compositions flag))) flags)
   #+end_src

3. Plot these compositions
   #+begin_src gnuplot :file /tmp/by-flag-sub-pop-comps.tex
     set term tikz
     
     # multiplot layout
     set tmargin 1.5
     set bmargin 0
     set lmargin 5
     set rmargin 5
     set multiplot layout 5,1 title "\nComposition of Sub-populations\n"
     
     # graph-wide options
     set style fill solid
     set style histogram rowstacked
     set style data histograms
     # set xrange [0:1024]
     unset title
     unset ytics
     unset xtics
     
     # plots
     set key above
     set ylabel 'O0'
     plot "< awk '{if(NR % 4 == 0){ print $0 }}' results/distributed-runs/bzip2/O0.composition" u 2 t 'O0', '' u 3 t 'O1', '' u 4 t 'O2', '' u 5 t 'O3', '' u 6 t 'Os'
     set tmargin 0
     unset key
     set ylabel 'O1'
     plot "< awk '{if(NR % 4 == 0){ print $0 }}' results/distributed-runs/bzip2/O1.composition" u 2, '' u 3, '' u 4, '' u 5, '' u 6
     set ylabel 'O2'
     plot "< awk '{if(NR % 4 == 0){ print $0 }}' results/distributed-runs/bzip2/O2.composition" u 2, '' u 3, '' u 4, '' u 5, '' u 6
     set ylabel 'O3'
     plot "< awk '{if(NR % 4 == 0){ print $0 }}' results/distributed-runs/bzip2/O3.composition" u 2, '' u 3, '' u 4, '' u 5, '' u 6
     set ylabel 'Os'
     plot "< awk '{if(NR % 4 == 0){ print $0 }}' results/distributed-runs/bzip2/OS.composition" u 2, '' u 3, '' u 4, '' u 5, '' u 6
     
     unset multiplot
   #+end_src

*** with better composition reporting and new naturalization
#+begin_src lisp
  (in-package :optimize)
  (defvar flag 'O0)
  (load "src/by-flag.lisp")
  
  ;; read a file
  (defvar flags (mapcar #'car ports))
  (defvar base "results/distributed-runs/bzip2")
  
  (defun collect (it)
    (let ((totals (mapcar {cons _ 0} flags)))
      (mapcar (lambda (line)
                (mapcar (lambda (f)
                          (incf (cdr (assoc f totals))
                                (or (cdr (assoc f line)) 0)))
                        flags)) it)
      (let ((total (reduce #'+ (mapcar #'cdr totals))))
        (mapcar (lambda-bind ((obj . cnt)) (cons obj (/ cnt total))) totals))))
  
  (defun cmps-for-flag (flag)
    (with-open-file (out (format nil "~a/~a.composition" base flag)
                         :direction :output :if-exists :supersede)
      ((lambda (cmps)
         (format out "~{~{~f~^ ~}~^~%~}~%"
                 (mapcar #'cons
                         (mapcar #'car cmps)
                         (mapcar [{mapcar #'cdr} #'collect #'cdr] cmps))))
       (read-from-string
        (format nil "(~a)" (file-to-string
                            (format nil "~a/~a/cmp.lisp" base flag)))))))
  
  (mapc #'cmps-for-flag flags)
#+end_src

** TODO Run Experiments [1/5]
*** DONE Preparation [7/7]
First we need
- [X] finalize power models (in file:src/optimize.lisp)
- [X] =optimize= arguments (in file:doc/optimize-args.txt)
- [X] file:bin/run works to check functionality
- [X] file:bin/mgmt compiles optimal baseline programs
- [X] select appropriate input sizes for each benchmark program
- [X] select appropriate GP parameters, (ask Steph if do both)
      | selection tournament |    2 |
      | eviction tournament  |    2 |
      | mutation             | 100% |
      | crossover            |   ?? |
- [X] tag the version of the repo which we'll use

*** TODO Main Experiment
AMD Runs
| benchmark    | machine | start                  | finish                 |  runtime |
|--------------+---------+------------------------+------------------------+----------|
| blackscholes | complex | <2013-07-10 Wed 06:18> | <2013-07-10 Wed 15:39> |     9.35 |
| bodytrack    | complex | <2013-07-09 Tue 12:58> | <2013-07-11 Thu 14:02> |    49.07 |
| facesim      | complex | <2013-07-15 Mon 11:06> |                        |          |
| ferret       | real    | <2013-07-10 Wed 14:14> | <2013-07-11 Thu 04:36> |    14.37 |
| fluidanimate | real    | <2013-07-09 Tue 09:27> | <2013-07-09 Tue 20:45> |    11.30 |
| freqmine     | complex | <2013-07-09 Tue 09:43> | <2013-07-10 Wed 03:50> |    18.12 |
| swaptions    | real    | <2013-07-09 Tue 09:29> | <2013-07-10 Wed 00:50> |    15.35 |
| vips         | real    | <2013-07-12 Fri 09:58> | <2013-07-13 Sat 03:37> |    17.65 |
| x264         | real    | <2013-07-10 Wed 14:17> | <2013-07-11 Thu 06:30> |    16.22 |
|--------------+---------+------------------------+------------------------+----------|
|              |         |                        |                        | 18.92875 |
#+TBLFM: $5=($4-$3)*24;%0.2f::@11$5=vmean(@2..@-1)

*** TODO Different Input Size Tests
AMD
| benchmark    | test | tiny | small | medium | large | huge |
|--------------+------+------+-------+--------+-------+------|
| blackscholes | x    | x    | x     | x      | x     | x    |
| bodytrack    | x    | x    | x     | x      | x     |      |
| facesim      |      |      |       |        |       |      |
| ferret       | x    | x    | x     | x      | x     | x    |
| fluidanimate | x    | x    | x     | x      | x     | x    |
| freqmine     | x    | x    | x     | x      | x     |      |
| swaptions    | x    | x    | x     | x      | x     | x    |
| vips         | x    | x    | x     | x      | x     | x    |
| x264         | x    | x    | x     | x      | x     | x    |

*** TODO Different Input Tests
*** TODO Extended Tests
| benchmark    | orig  | opt   |
|--------------+-------+-------|
| blackscholes | 10/10 | 10/10 |
| bodytrack    | 10/10 | 6/10  |
| facesim      |       |       |
| ferret       | 10/10 | 5/10  |
| fluidanimate | 10/10 | 0/10  |
| freqmine     | 10/10 | 3/10  |
| swaptions    | 10/10 | 10/10 |
| vips         |       |       |
| x264         |       |       |

**** Full results
| benchmark    | vsn  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
|--------------+------+------+------+------+------+------+------+------+------+------+------|
| blackscholes | orig | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| blackscholes | opt  | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| bodytrack    | orig | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| bodytrack    | opt  | pass | pass | FAIL | pass | FAIL | pass | FAIL | FAIL | pass | pass |
| facesim      | orig |      |      |      |      |      |      |      |      |      |      |
| facesim      | opt  |      |      |      |      |      |      |      |      |      |      |
| ferret       | orig | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| ferret       | opt  | pass | pass | FAIL | FAIL | pass | FAIL | FAIL | pass | FAIL | pass |
| fluidanimate | orig | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| fluidanimate | opt  | FAIL | FAIL | FAIL | FAIL | FAIL | FAIL | FAIL | FAIL | FAIL | FAIL |
| freqmine     | orig | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| freqmine     | opt  | pass | FAIL | FAIL | FAIL | pass | FAIL | FAIL | FAIL | FAIL | pass |
| swaptions    | orig | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| swaptions    | opt  | pass | pass | pass | pass | pass | pass | pass | pass | pass | pass |
| vips         | orig |      |      |      |      |      |      |      |      |      |      |
| vips         | opt  |      |      |      |      |      |      |      |      |      |      |
| x264         | orig |      |      |      |      |      |      |      |      |      |      |
| x264         | opt  |      |      |      |      |      |      |      |      |      |      |

** TODO Analyze Optimizations
*** Overall energy reduction
**** runtime
#+name: overall-runtime-reduction
#+begin_src sh
  . bin/common
  
  # have to protect against weird inf values... something broke w/ferret
  final(){
      for b in $1/best-*;do
          ./bin/objread $b -E '(aget :seconds (stats obj))'
      done|grep -v NIL|sort -n|head -1; }
  
  #for arch in amd intel;do
  for arch in amd;do
      for bench in ${BENCHMARKS[@]};do
          log=results/$arch/$bench/optimize.log
          stats=results/$arch/$bench/stats.txt
          if [ -f $log ];then
              initial=$(grep ":SECONDS" $log \
                  |sed 's/^.*:SECONDS \. //;s/[^0-9\.].*$//')
              final=$(final results/$arch/$bench)
          else
              initial="NA"
              final="NA"
          fi
          echo "$arch $bench $initial $final"
      done
  done
#+end_src

| arch | benchmark    |      orig |  optimized | % reduction |
|------+--------------+-----------+------------+-------------|
| amd  | blackscholes | 3.0408022 | 0.24908768 |   91.808488 |
| amd  | bodytrack    | 1.7050157 |  1.6289097 |   4.4636539 |
| amd  | facesim      | 10.872234 |  10.731139 |             |
| amd  | ferret       | 1.4337407 |   1.313766 |   8.3679497 |
| amd  | fluidanimate | 1.2734555 |  1.0789438 |   15.274323 |
| amd  | freqmine     |           |            |             |
| amd  | swaptions    | 2.8203497 |  1.6898595 |   40.083334 |
| amd  | vips         | 3.6553993 |  2.4844027 |   32.034711 |
| amd  | x264         | 1.8912624 |   1.664994 |   11.963882 |
|------+--------------+-----------+------------+-------------|
|      |              |           |            |   29.142335 |
#+TBLFM: $5=(100*($3-$4)/$3)::@11$5=vmean(@2..@-1)

**** modeled
#+name: overall-energy-reduction
#+begin_src sh
  . bin/common
  
  # have to protect against weird inf values... something broke w/ferret
  final(){
      cat $1|cut -d' ' -f2|grep -v inf|sort -n|head -1; }
  
  for arch in amd intel;do
      for bench in ${BENCHMARKS[@]};do
          log=results/$arch/$bench/optimize.log
          stats=results/$arch/$bench/stats.txt
          if [ -f $log ];then
              initial=$(grep ":ORIG-FITNESS" $log|sed 's/^.*\. //;s/))$//')
              final=$(final $stats)
          else
              initial="NA"
              final="NA"
          fi
          echo "$arch $bench $initial $final"
      done
  done
#+end_src

#+RESULTS: manicured-overall-energy-reduction
| arch | benchmark    |   initial |     final | % reduction |
|------+--------------+-----------+-----------+-------------|
| amd  | blackscholes | 1079.9546 |   64.8971 |   93.990757 |
| amd  | bodytrack    | 568.41156 |  540.5206 |   4.9068249 |
| amd  | facesim      |           |           |             |
| amd  | ferret       | 472.13297 | 421.91614 |   10.636163 |
| amd  | fluidanimate | 416.33728 |   339.564 |   18.440165 |
| amd  | freqmine     |  668.3218 | 601.47565 |   10.002090 |
| amd  | swaptions    |  909.4299 | 518.23346 |   43.015568 |
| amd  | vips         | 1063.0033 |  710.5062 |   33.160490 |
| amd  | x264         | 349.83527 |   293.697 |   16.047058 |
|------+--------------+-----------+-----------+-------------|
|      |              |           |           |   28.774889 |
#+TBLFM: $5=100 * ($3 - $4)/$3::@11$5=vmean(@2..@-1)

**** measured
| benchmark    | original kwh | best kwh | % reduction |
|--------------+--------------+----------+-------------|
| blackscholes |       0.0057 |   0.0004 |   92.982456 |
| bodytrack    |              |          |             |
| facesim      |              |          |             |
| ferret       |       0.0025 |   0.0025 |          0. |
| fluidanimate |       0.0023 |    0.002 |   13.043478 |
| freqmine     |       0.0051 |   0.0046 |   9.8039216 |
| swaptions    |       0.0054 |    0.003 |   44.444444 |
| vips         |              |          |             |
| x264         |       0.0034 |    0.003 |   11.764706 |
|--------------+--------------+----------+-------------|
|              |              |          |   28.673168 |
#+TBLFM: $4=100 * ($2-$3)/$2::@11$4=vmean(@2..@-1)

#+begin_src sh
  . bin/common
  RESULTS=/nfs/adaptive/data/opt/results/amd/
  for bench in ${BENCHMARKS[@]};do
      DIR=$RESULTS/$bench
      if [ -d $DIR ];then
          ./bin/best $DIR|head -10|./bin/multi-power $bench $DIR -r 20 \
              |tee $bench-power.csv
      fi
  done
#+end_src

*** Histograms of improvement
#+begin_src gnuplot :var data=overall-energy-reduction
  set title 'Energy Optimization Results'
  unset key
  set style data histograms
  set style histogram cluster gap 1
  set style fill solid border -1
  set boxwidth 0.9
  set auto x
  set xtic rotate by -45
  set yrange [0:100]
  set ylabel "Percent Energy Reduction"
  set xlabel "Benchmark"
  plot data u (100 * ((column(3) - column(4)) / column(3))):xtic(2) ti col
#+end_src

*** Graphs of improvement by evaluations by benchmarks
#+begin_src gnuplot :file etc/data/improvement-by-evals-by-benchmarks.svg
  set term svg size 1200,800
  set multiplot layout 3,3 title 'Energy Reduction by Fitness Evaluations'
  do for [bench in "blackscholes ferret fluidanimate freqmine swaptions x264"] {
    set title bench
    plot "results/amd/".bench."/stats.txt" u 1:2 w lines notitle
  }
  unset multiplot
#+end_src

#+RESULTS:
[[file:etc/data/improvement-by-evals-by-benchmarks.svg]]

*** Histogram of improvement by input size
**** energy reduction
see [[*all%20benchmarks%20(we%20have)%20over%20all%20inputs][all benchmarks (we have) over all inputs]]

1. collect results
   #+name: energy-comparison
   #+begin_src sh :cache yes
     . bin/common
     
     power(){
         cut -d, -f1,$1|awk -F, 'OFS="," {print $2,$1}' \
             |./bin/calc-energy -m amd-opteron-power-model; }
     
     base=results/amd-opt-by-size
     
     echo "benchmark,small,,medium,,large,,huge,"
     for bench in ${BENCHMARKS[@]};do
         echo -n "$bench,"
         for size in small medium large huge;do
             file=$base/$bench-$size.csv
             if [ -f $file ] && \
                 [ $(grep error $file|cut -d, -f2) -eq 0 ] && \
                 [ $(grep error $file|cut -d, -f3) -eq 0 ];then
                 echo -n "$(cat $file|power 2),$(cat $file|power 3),"
             else
                 echo -n "NA,NA,"
             fi
         done
         echo ""
     done|sed 's/,$//'
   #+end_src

   #+RESULTS[4cb495efcf6dbf90ca14da469a96a61463076959]: energy-comparison
   | benchmark    |     small |           |    medium |           | large     |           | huge        |           |
   | blackscholes |  66.60791 |   4.83037 | 271.33185 | 16.524755 | 1082.9415 | 65.79707  | 157431.75   | 9728.703  |
   | bodytrack    | 165.79736 | 160.81306 | 535.19275 |  521.2339 | 1905.3456 | 1858.862  | NA          | NA        |
   | facesim      |        NA |        NA |        NA |        NA | NA        | NA        | NA          | NA        |
   | ferret       |  161.1923 | 146.59804 | 477.73395 | 429.60913 | 2113.6077 | 1830.0222 | NA          | NA        |
   | fluidanimate |        NA |        NA | 421.42395 |  357.1908 | NA        | NA        | NA          | NA        |
   | freqmine     |  706.8656 |  607.6356 |        NA |        NA | NA        | NA        | NA          | NA        |
   | swaptions    | 226.42577 | 132.70084 |   903.955 |  534.5128 | 3638.7085 | 2128.7698 | 178492.34   | 105277.53 |
   | vips         |        NA |        NA | 1127.7108 | 716.54816 | NA        | NA        | -0.15889622 | 1.4027784 |
   | x264         | 401.76398 | 349.53668 |        NA |        NA | NA        | NA        | NA          | NA        |

2. correlate results
   #+name: collated-energy-comparison
   #+begin_src lisp :var data=energy-comparison
     (defun odds (list &aux (counter 0))
       (loop :for i :in list :do (incf counter) :when (oddp counter) :collect i))

     (defun evens (list &aux (counter 0))
       (loop :for i :in list :do (incf counter) :when (evenp counter) :collect i))

     (defun trans (list) (apply #'mapcar #'list list))

     (let* ((it (trans data))
            (collated
             (mapcar #'append
                     (cons (car it) (odds (cdr it)))
                     (cons (car it) (evens (cdr it))))))
       (trans (cons '(size small medium large huge)
                    (cddr (sort (trans collated) #'string< :key #'car)))))
   #+end_src

   #+RESULTS: collated-energy-comparison
   | SIZE   | blackscholes | blackscholes | bodytrack | bodytrack | facesim | facesim |    ferret |    ferret | fluidanimate | fluidanimate | freqmine | freqmine | swaptions | swaptions | vips        | vips      | x264      | x264      |
   | SMALL  |     66.60791 |      4.83037 | 165.79736 | 160.81306 | NA      | NA      |  161.1923 | 146.59804 | NA           | NA           | 706.8656 | 607.6356 | 226.42577 | 132.70084 | NA          | NA        | 401.76398 | 349.53668 |
   | MEDIUM |    271.33185 |    16.524755 | 535.19275 |  521.2339 | NA      | NA      | 477.73395 | 429.60913 | 421.42395    | 357.1908     | NA       | NA       |   903.955 |  534.5128 | 1127.7108   | 716.54816 | NA        | NA        |
   | LARGE  |    1082.9415 |     65.79707 | 1905.3456 |  1858.862 | NA      | NA      | 2113.6077 | 1830.0222 | NA           | NA           | NA       | NA       | 3638.7085 | 2128.7698 | NA          | NA        | NA        | NA        |
   | HUGE   |    157431.75 |     9728.703 |        NA |        NA | NA      | NA      |        NA |        NA | NA           | NA           | NA       | NA       | 178492.34 | 105277.53 | -0.15889622 | 1.4027784 | NA        | NA        |

3. display results
   #+headers: :file etc/pub/evolved-improvement-by-input.tex
   #+begin_src gnuplot :var data=collated-energy-comparison
     set term tikz
     set title 'evolved improvement in modeled energy by input size'
     set datafile missing "NA"
     set key above
     set style data histograms
     set auto x
     set style histogram cluster gap 1
     set style fill solid border -1
     set boxwidth 0.9
     # set xtic rotate by -12.25
     set ylabel "percent energy reduction"
     set xlabel "input size"
     plot for [n=2:14:2] data u (100 * ((column(n) - column(n + 1)) / column(n))):xtic(1) ti col
   #+end_src

**** other issues by size
***** error
#+begin_src sh
  . bin/common
  
  base=results/amd-opt-by-size
  
  echo "benchmark,small,,medium,,large,,huge,"
  for bench in ${BENCHMARKS[@]};do
      echo -n "$bench,"
      for size in small medium large huge;do
          file=$base/$bench-$size.csv
          if [ -f $file ];then
              echo -n "$(grep error $file|cut -d, -f2,3),"
          else
              echo -n "NA,NA,"
          fi
      done
      echo ""
  done|sed 's/,$//'
#+end_src

#+RESULTS:
| benchmark    | small |    | medium |    | large |    | huge |    |
| blackscholes |     0 |  0 |      0 |  0 |     0 |  0 |    0 |  0 |
| bodytrack    |     0 |  0 |      0 |  0 |     0 |  0 |    1 |  1 |
| facesim      |    NA | NA |     NA | NA |    NA | NA |   NA | NA |
| ferret       |     0 |  0 |      0 |  0 |     0 |  0 |   16 | 16 |
| fluidanimate |     0 |  2 |      0 |  0 |     0 |  2 |    0 |  2 |
| freqmine     |     0 |  0 |      0 |  1 |     0 |  1 |    2 |  2 |
| swaptions    |     0 |  0 |      0 |  0 |     0 |  0 |    0 |  0 |
| vips         |     0 |  2 |      0 |  0 |     0 |  2 |    0 |  0 |
| x264         |     0 |  0 |      0 |  2 |     0 |  2 |    0 |  2 |

***** seconds
#+begin_src sh
  . bin/common
  
  base=results/amd-opt-by-size
  
  echo "benchmark,small,,medium,,large,,huge,"
  for bench in ${BENCHMARKS[@]};do
      echo -n "$bench,"
      for size in small medium large huge;do
          file=$base/$bench-$size.csv
          if [ -f $file ];then
              echo -n "$(grep second $file|cut -d, -f2,3),"
          else
              echo -n "NA,NA,"
          fi
      done
      echo ""
  done|sed 's/,$//'
#+end_src

#+RESULTS:
| benchmark    |       small |             |       medium |              |         large |              |           huge |                |
| blackscholes | 0.187692442 | 0.017415448 |  0.764755907 |  0.065281222 |   3.047209719 |   0.25355994 |  444.768667995 |   37.732167101 |
| bodytrack    | 0.498711849 | 0.485352237 |  1.603426342 |  1.565523042 |   5.681577725 |  5.567982263 |                |                |
| facesim      |          NA |          NA |           NA |           NA |            NA |           NA |             NA |             NA |
| ferret       | 0.499703248 | 0.462268506 |   1.44420668 |  1.317697672 |    6.31263199 |  5.556126241 |  560.009379427 |   516.51501811 |
| fluidanimate | 0.580568447 | 0.011042083 |  1.291994643 |  1.123603631 |   4.215639506 |  3.554625315 |  649.848555536 |   16.807834724 |
| freqmine     |  2.74416897 | 2.433659269 |  49.07001685 |  0.567490046 | 195.032431043 |  1.178472107 | 4778.060176806 |    4.125127682 |
| swaptions    | 0.695905836 | 0.424635963 |  2.780658253 |  1.703306782 |  11.181952665 |  6.794015413 |  550.389700756 |  336.496063275 |
| vips         | 1.213408887 | 0.659827449 |  3.820339512 |  2.502110461 |   9.995269895 |  5.611226583 |     0.00679999 |    0.007162996 |
| x264         | 1.881809527 | 1.675157933 | 13.808103916 | 12.426627889 |  45.238713212 | 38.650996354 | 1471.939535268 | 1316.583726381 |

** Build optimization Taxonomy
This might be too optimistic.

** CANCELED Find Warehouse Compute Benchmark Applications
** CANCELED Build a Memory Fitness Function
We could use the "bubble" and the "reporter" from [[#mars2011bubble]].
Measuring the values of HW counters against the bubble could give us
coefficients for a memory linear model.

* Code Tasks [8/8]
** DONE inefficient mgmt generated executables
| benchmark    | Intel | AMD |
|--------------+-------+-----|
| blackscholes |     7 |   1 |
| bodytrack    |    33 |   1 |
| facesim      |   1.1 | 1.1 |
| ferret       |   0.9 | 0.9 |
| fluidanimate |     1 |   1 |
| freqmine     |     1 |  1\dagger |
| swaptions    |   0.9 | 0.9 |
| vips         |       |   1 |
| x264         |     7 |   \Dagger |

\dagger was 3.1, but fix by including -fopenmp in the mgmt build

\Dagger x264 built with parsec includes hand-written ASM, while the version
  built by mgmt is uses the alternate C source code.  On our AMD
  machine the parsecmgmt version segfaults

We need to figure out why blackscholes and bodytrack are bad on Intel,
and why freqmine is bad on AMD.

*** looking more closely at vips (close enough)
: 11:32 bagel:optimization run vips benchmarks/vips/vips -p -r 30
: 0,exit
: 0,error
: 5413108972,cycles,0.16%
: 11737336469,instructions,0.02%
: 205986621,r532010,0.14%
: 807222342,r538010,0.07%
: 12496268,cache-references,0.47%
: 695815,cache-misses,2.49%
: 2.004006300,seconds,0.16%
: 11:33 bagel:optimization run vips benchmarks/vips/vips.orig -p -r 30
: 0,exit
: 0,error
: 5323433291,cycles,0.23%
: 11852050777,instructions,0.01%
: 206823948,r532010,0.14%
: 802740885,r538010,0.07%
: 12271097,cache-references,0.53%
: 640607,cache-misses,3.23%
: 1.967453561,seconds,0.23%

|  2.004006300 | 0.16 |
|  1.967453561 | 0.23 |
|--------------+------|
| -0.018578705 |      |
#+TBLFM: @3$1=(@2-@1)/@2

** DONE re-run when we get not-counted
This means perf ran two quickly.  Use half the counters.

This is now implemented in the file:bin/run script.

** DONE focus mutation operators on hot spots
- use =perf annotate= to highlight "hot" instructions
- focus mutations on those instructions
- maintain annotations over mutations

Process
1. [X] use the run script to collect perf annotation by memory address
2. [X] associate each assembly instruction with a memory address
   1. [X] get the function names in the ASM file
   2. [X] collect the addresses and the lines of code for each function
   3. [X] associate addresses with lines of code
3. [X] map perf percents through addresses to lines of code

** DONE MCMC search strategy
- top level search driver
- possibly a fixed with 

Thoughts
- we want the walk to be ergodic, which will allow us to sample the
  whole space independent of our 

- no deletion, rather just moving code around between two buckets,
  one which serializes to disk, and one which is ignored, but keeps
  the relative instruction mix the same

- the following function of the fitness of a step decides if it is
  taken or not

  \begin{equation*}
    keep = \left \{
    \begin{array}{cl}
    1 & if  f_{1} > f_{0} \\
    \frac{f_{1}}{f_{0}} & otherwise
    \end{array}
    \right .
  \end{equation*}
  (metropolis hasting step)
  ("gibbs" would be another option using /e/)

** DONE Memory efficient diff-rep for large genomes
see [[https://github.com/eschulte/software-evolution/blob/master/software/simple.lisp#L161][software-evolution/software/simple.lisp#L161]]

** DONE add GC flag to optimize executable
with separate help and default for SBCL and CCL

** DONE =asm-perf-light= for smaller memory footprint
with command line flag

: OPTIMIZE> (progn (setf *population* nil) (ccl:gc))
: NIL
: OPTIMIZE> (time (setf *population* (loop :for n :below 16 :collect (copy *orig*))))
: (SETF *POPULATION* (LOOP :FOR N :BELOW 16 :COLLECT (COPY *ORIG*)))
: took 11,668 milliseconds (11.668 seconds) to run.
:      11,172 milliseconds (11.172 seconds, 95.75%) of which was spent in GC.
: During that period, and with 4 available CPU cores,
:      11,540 milliseconds (11.540 seconds) were spent in user mode
:         140 milliseconds ( 0.140 seconds) were spent in system mode
:  242,969,352 bytes of memory allocated.
:  51,143 minor page faults, 0 major page faults, 0 swaps.
: (...)
: OPTIMIZE> (ccl:lisp-heap-gc-threshold)
: 16777216
: OPTIMIZE> (ccl:set-lisp-heap-gc-threshold (expt 2 28))
: 268500992
: OPTIMIZE> (progn (setf *population* nil) (ccl:gc))
: NIL
: OPTIMIZE> (time (setf *population* (loop :for n :below 16 :collect (copy *orig*))))
: (SETF *POPULATION* (LOOP :FOR N :BELOW 16 :COLLECT (COPY *ORIG*)))
: took 3,307 milliseconds (3.307 seconds) to run.
:      2,865 milliseconds (2.865 seconds, 86.63%) of which was spent in GC.
: During that period, and with 4 available CPU cores,
:      3,310 milliseconds (3.310 seconds) were spent in user mode
:         20 milliseconds (0.020 seconds) were spent in system mode
:  242,969,352 bytes of memory allocated.
: (...)
: OPTIMIZE> (progn (setf *population* nil) (ccl:gc))
: NIL
: OPTIMIZE> (time (prog2 (ccl:egc nil) (setf *population* (loop :for n :below 16 :collect (copy *orig*))) (ccl:egc t)))
: (PROG2 (CCL:EGC NIL) (SETF *POPULATION* (LOOP :FOR N :BELOW 16 :COLLECT (COPY *ORIG*))) (CCL:EGC T))
: took 474 milliseconds (0.474 seconds) to run.
: During that period, and with 4 available CPU cores,
:      410 milliseconds (0.410 seconds) were spent in user mode
:       70 milliseconds (0.070 seconds) were spent in system mode
:  242,969,352 bytes of memory allocated.
:  53,176 minor page faults, 0 major page faults, 0 swaps.
: (...)
: OPTIMIZE> (ccl:set-lisp-heap-gc-threshold 16777216)
: 16777216
: OPTIMIZE> (setf *orig* (to-asm-light *orig*))
: #<ASM-LIGHT #x2AC49356>
: OPTIMIZE> (progn (setf *population* nil) (ccl:gc))
: NIL
: OPTIMIZE> (time (setf *population* (loop :for n :below 16 :collect (copy *orig*))))
: (SETF *POPULATION* (LOOP :FOR N :BELOW 16 :COLLECT (COPY *ORIG*)))
: took 5,965 milliseconds (5.965 seconds) to run.
:      5,827 milliseconds (5.827 seconds, 97.69%) of which was spent in GC.
: During that period, and with 4 available CPU cores,
:      5,970 milliseconds (5.970 seconds) were spent in user mode
:          0 milliseconds (0.000 seconds) were spent in system mode
:  80,991,208 bytes of memory allocated.
:  16,364 minor page faults, 0 major page faults, 0 swaps.
: (...)
: OPTIMIZE> (ccl:set-lisp-heap-gc-threshold (expt 2 28))
: 268500992
: OPTIMIZE> (progn (setf *population* nil) (ccl:gc))
: NIL
: OPTIMIZE> (time (prog2 (ccl:egc nil) (setf *population* (loop :for n :below 16 :collect (copy *orig*))) (ccl:egc t)))
: (PROG2 (CCL:EGC NIL) (SETF *POPULATION* (LOOP :FOR N :BELOW 16 :COLLECT (COPY *ORIG*))) (CCL:EGC T))
: took 114 milliseconds (0.114 seconds) to run.
: During that period, and with 4 available CPU cores,
:      110 milliseconds (0.110 seconds) were spent in user mode
:        0 milliseconds (0.000 seconds) were spent in system mode
:  80,990,472 bytes of memory allocated.
: (...)
: OPTIMIZE> 

** DONE add version information
- git and CL info
- command line option and in log file

** minimal test suite
Including tests for mgmt and run which should output tables of
failures at stages.

Run with =make check=.

* Issues [10/10]
** breeding the best back with the original
Almost instantly (first 256 evaluations) found a compromise individual
which slightly reduced performance from the optimized, but passed all
extended tests.

reduces energy efficiency from best optimized individual by
#+begin_src lisp
  (let ((cross (fitness *best*))
        (opt 601.47565)
        (orig 668.3218))
    (list
     (* 100 (/ (- opt cross) opt))
     (* 100 (/ (- orig cross) orig))))
#+end_src

#+RESULTS:
| -1.5789008 | 8.58111 |

The crossbreed version of freqmine has 29 differences from the
original, while the result of optimization has 62.  Less than half.

: $ diff freqmine-breed-total/orig.s freqmine-breed-total/best-243200.s|grep -c "\-\-\-"
: 62
: $ diff freqmine-breed-total/orig.s freqmine-breed-total/crossbreed.s|grep -c "\-\-\-"
: 29

** ASM path correlation
#+begin_src sh :results verbatim
  . bin/common
  
  for bench in ${BENCHMARKS[@]};do
      for size in small medium large;do
          rm benchmarks/$bench/$bench.{input,output}
          mgmt output $bench -s $size
          link=""
          if [ ! "$(grep $bench etc/optimize-args|cut -f2)" == "" ];then
              link="-l \"$(grep $bench etc/optimize-args|cut -f2)\""
          fi
          flag=""
          if [ ! "$(grep $bench etc/optimize-args|cut -f3)" == "" ];then
              flag="-f \"$(grep $bench etc/optimize-args|cut -f3)\""
          fi
          output=$bench-$size.ann
          echo $output
          annotate $bench benchmarks/$bench/$bench.s $link $flag -s $size > $output
      done
  done
#+end_src

*** correlation
The correlation of vips with medium input and vips with small input is,
#+begin_src sh
  join <(sort -k 1b,1 /tmp/vips-medium.ann) <(sort -k 1b,1 /tmp/vips-small.ann) \
      |sed 's/ /,/g'|cut -d, -f2-|./bin/correlation
#+end_src

#+RESULTS:
|    |        V1 |        V2 |
| V1 |       1.0 | 0.2408207 |
| V2 | 0.2408207 |       1.0 |

** unexpected non-functional issues during large runs
Leftover Files
- facesim requires removal of compilation files from TMPDIR

Large Data
- freqmine on huge input can us 86G in the benchmark and tmp directories

** DONE facesim is running really slowly on AMD
|                5.700 |  6400 |
|                 6.00 |  6656 |
|  6.36666666666666664 |  6912 |
|                6.700 |  7168 |
|  7.33333333333333335 |  7424 |
|  7.36666666666666664 |  7680 |
|   7.7333333333333333 |  7936 |
|   8.6666666666666667 |  8192 |
|  8.46666666666666664 |  8448 |
|   8.7666666666666667 |  8704 |
|  9.11666666666666666 |  8960 |
|                9.450 |  9216 |
|   9.8333333333333334 |  9472 |
| 10.16666666666666664 |  9728 |
|               10.500 |  9984 |
|  10.8333333333333334 | 10240 |
| 11.16666666666666664 | 10496 |
|  11.5166666666666667 | 10752 |
|               11.850 | 11008 |

- slope :: 4608 / 6.1499999999999995 =
  - 749.2682926829269 evals an hour

- runtime :: 262144 / 749.2682926829269 =
  - 349.8666666666666 hours
  - 14.577777777777776 days

** DONE freqmine compiled w/mgmt takes too long
#+begin_quote
I should mention that I ran all benchmarks using bin/run *except*
freqmine. I ran freqmine using parsecmgmt since bin/run took over 10
minutes before I killed it; parsecmgmt took about 5 seconds to run
that benchmark.
#+end_quote

Freqmine takes *very* long whenever it writes output.  The only reason
it goes quickly in parsec runs is because no output file is created.

: OMP_NUM_THREADS=1

** DONE do we trust run to measure output [4/4]
| benchmark    | status                                           |
|--------------+--------------------------------------------------|
| blackscholes | okay                                             |
| bodytrack    | will improve                                     |
| facesim      | will improve                                     |
| ferret       | okay                                             |
| fluidanimate | okay                                             |
| freqmine     | will improve                                     |
| raytrace     | removed from benchmark suite, no testable output |
| swaptions    | will improve                                     |
| vips         | okay                                             |
| x264         | okay                                             |

Tests to be improved
- [X] bodytrack :: bodytrack writes outputs to the input directory, so
                   we will generate a new temporary input directory
                   for each evaluation, and loop through diffing every
                   file in the input directory against oracle output,
                   and will check to ensure extra files aren't
                   created.
- [X] facesim :: we will add a check to ensure extra files aren't
                 created.
- [X] freqmine :: we will perform a more strict diff of the output
- [X] swaptions :: we will perform a more strict diff of the output

** DONE energy by input size
See how the model calculated energy varies by input size for both
evolved and original programs.

*** Jonathan debug
| input    | runtime orig |   |
|----------+--------------+---|
| 10000000 |          137 |   |
| large    |           .9 |   |

*** blackscholes powers of ten
#+headers: :colnames '("input size" "model energy orig." "model energy evolved")
#+begin_src sh :tangle /tmp/analyze :shebang #!/bin/bash
  IN="etc/data/bs-multi-inputs.txt"
  
  output(){
      cat $IN|sed -n "/size,$size\$/,/task-clock/p"|grep -v size|grep -v "^$" \
          |cut -d, -f1,$1|awk -F, 'OFS="," {print $2,$1}' \
          |./bin/calc-energy -m amd-opteron-power-model; }
  
  for exp in $(seq 1 8);do
      size=$(echo "10^$exp"|bc)
      ORIG=$(output 2)
      if [ ! $? -eq 0 ];then ORIG="xxxx"; fi
      EVOL=$(output 3)
      if [ ! $? -eq 0 ];then EVOL="xxxx"; fi
      echo "$size $ORIG $EVOL"
  done|grep -v "UNBOUND-VARIABLE"
#+end_src

#+RESULTS:
| input size | model energy orig. | model energy evolved | % reduction |
|------------+--------------------+----------------------+-------------|
|       1000 |          15.932569 |          0.028890664 |   99.818669 |
|      10000 |          151.78835 |            11.509285 |   92.417544 |
|     100000 |          1539.6437 |           105.949684 |   93.118558 |
|    1000000 |          15187.705 |            1031.8695 |   93.205889 |
|   10000000 |          152615.44 |            10389.495 |   93.192370 |
|  100000000 |          1528770.8 |            103024.76 |   93.260941 |
#+TBLFM: $4=100*($2-$3)/$2

*** all benchmarks (we have) over all inputs
    :PROPERTIES:
    :ID:       a21a79d2-39f3-4eb4-916e-f63983e7cdf7
    :END:
**** collect results
Parse results
#+name: energy-comparison
#+begin_src sh :cache yes
  . bin/common
  
  power(){
      cut -d, -f1,$1|awk -F, 'OFS="," {print $2,$1}' \
          |./bin/calc-energy -m amd-opteron-power-model; }
  
  base=results/amd-opt-by-size
  
  echo "benchmark,small,,medium,,large,,huge,"
  for bench in ${BENCHMARKS[@]};do
      echo -n "$bench,"
      for size in small medium large huge;do
          file=$base/$bench-$size.csv
          if [ -f $file ];then
              echo -n "$(cat $file|power 2),$(cat $file|power 3),"
          else
              echo -n "NA,NA,"
          fi
      done
      echo ""
  done|sed 's/,$//'
#+end_src

#+RESULTS[7fa25c01e1805fb1359385d3f6bf7c4f3101a465]: energy-comparison
| benchmark    |     small |           |    medium |           |     large |           | huge        |           |
| blackscholes |  66.60791 |   4.83037 | 271.33185 | 16.524755 | 1082.9415 |  65.79707 | NA          | NA        |
| bodytrack    | 165.79736 | 160.81306 | 535.19275 |  521.2339 | 1905.3456 |  1858.862 | NA          | NA        |
| ferret       |  161.1923 | 146.59804 | 477.73395 | 429.60913 | 2113.6077 | 1830.0222 | 181551.03   | 161716.45 |
| fluidanimate |  193.1168 | 3.7036355 | 421.42395 |  357.1908 | 1398.9271 | 1141.8993 | NA          | NA        |
| freqmine     |  706.8656 |  607.6356 | 11939.437 | 155.58197 | 46834.918 |  327.1728 | NA          | NA        |
| swaptions    | 226.42577 | 132.70084 |   903.955 |  534.5128 | 3638.7085 | 2128.7698 | NA          | NA        |
| x264         | 401.76398 | 349.53668 |  2874.418 | 2509.6873 |  9448.305 |  7828.587 | 298431.2    | 262761.16 |

**** collate results
#+name: collated-energy-comparison
#+begin_src lisp :var data=energy-comparison
  (defun odds (list &aux (counter 0))
    (loop :for i :in list :do (incf counter) :when (oddp counter) :collect i))
  
  (defun evens (list &aux (counter 0))
    (loop :for i :in list :do (incf counter) :when (evenp counter) :collect i))
  
  (defun trans (list) (apply #'mapcar #'list list))
  
  (let* ((it (trans data))
         (collated
          (mapcar #'append
                  (cons (car it) (odds (cdr it)))
                  (cons (car it) (evens (cdr it))))))
    (trans (cons '(size small medium large huge)
                 (cddr (sort (trans collated) #'string< :key #'car)))))
#+end_src

#+RESULTS: collated-energy-comparison
| SIZE   | blackscholes | blackscholes | bodytrack | bodytrack |    ferret |    ferret | fluidanimate | fluidanimate |  freqmine |  freqmine | swaptions | swaptions |      x264 |      x264 |
| SMALL  |     66.60791 |      4.83037 | 165.79736 | 160.81306 |  161.1923 | 146.59804 |     193.1168 |    3.7036355 |  706.8656 |  607.6356 | 226.42577 | 132.70084 | 401.76398 | 349.53668 |
| MEDIUM |    271.33185 |    16.524755 | 535.19275 |  521.2339 | 477.73395 | 429.60913 |    421.42395 |     357.1908 | 11939.437 | 155.58197 |   903.955 |  534.5128 |  2874.418 | 2509.6873 |
| LARGE  |    1082.9415 |     65.79707 | 1905.3456 |  1858.862 | 2113.6077 | 1830.0222 |    1398.9271 |    1141.8993 | 46834.918 |  327.1728 | 3638.7085 | 2128.7698 |  9448.305 |  7828.587 |
| HUGE   |           NA |           NA |        NA |        NA | 181551.03 | 161716.45 |           NA |           NA |        NA |        NA |        NA |        NA |  298431.2 | 262761.16 |

**** graph results
#+headers: :file etc/data/evolved-improvement-by-input.svg
#+begin_src gnuplot :var data=collated-energy-comparison
  set title 'evolved improvement in modeled energy by input size'
  set datafile missing "NA"
  set key above
  set style data histograms
  set auto x
  set style histogram cluster gap 1
  set style fill solid border -1
  set boxwidth 0.9
  set xtic rotate by -45
  set ylabel "percent energy reduction"
  set xlabel "input size"
  plot for [n=2:14:2] data u (100 * ((column(n) - column(n + 1)) / column(n))):xtic(1) ti col
#+end_src

#+RESULTS:
[[file:etc/data/evolved-improvement-by-input.svg]]

*** correctness over multiple inputs
#+name: evolved-error-by-size
#+begin_src sh :cache yes
  err(){
      cat $1|grep error|cut -d, -f$2; }
  base=results/evo-cmp/
  echo "bench,small,,medium,,large,,huge,,"
  for bench in blackscholes ferret fluidanimate freqmine swaptions x264;do
      echo -n "$bench,"
      for size in small medium large huge;do
          file=$base/$bench-$size.csv
          if [ -f $file ];then
              echo -n "$(err $file 2),$(err $file 3),"
          else
              echo -n "NA,NA,"
          fi
      done
      echo ""
  done
#+end_src

#+RESULTS[60cb11fa4c2bb04447401327aa6b5c55e1f312a4]: evolved-error-by-size
| bench        | small |   | medium |   | large |   | huge |    |
|--------------+-------+---+--------+---+-------+---+------+----|
| blackscholes |     0 | 0 |      0 | 0 |     0 | 0 |    0 |  0 |
| ferret       |     0 | 0 |      0 | 0 |     0 | 0 |   16 | 16 |
| fluidanimate |     0 | 1 |      0 | 0 |     0 | 0 |    1 |  1 |
| swaptions    |     0 | 0 |      0 | 0 |     0 | 0 |    0 |  0 |
| x264         |     0 | 0 |      0 | 2 |     0 | 2 |    0 |  2 |

** DONE we don't correctly catch non-zero returns
** DONE Running out of memory
#+begin_quote
> As it turns out, after much investigation of how I could be leaking
> massive amounts of cons cells and strings--the two main ingredients in
> my GP object which are constantly being created, tested and
> destroyed. Ultimately I believe that my problem isn't a memory leak, but
> is rather that I've done a poor job of configuring SBCL's GC to my
> application domain.

Or you're getting bit by the spectacularly coarse granularity of the
conservative roots.  Have a look at SB-EXT:GC-LOGFILE, use it, and check
the output to see how many pinned pages there are per generation.  All of
the objects in all of those pages are considered by the GC to be "live",
and this can sometimes cause quite a bit of garbage to be retained.
#+end_quote

*** efficiently generate large populations with ccl
#+begin_quote
: 12:24 < gbyers> It probably has less to do with GC precision 
:                 than with GC frequency.  The manual discusses 
:                 how to tune this.
: 12:28 < gbyers> An ephemeral/generational GC operates under the 
:                 assumption that most newly-created objects are 
:                 very short-lived.   If you're allocating lots of 
:                 long-lived objects, then it won't be very 
:                 effective.  By default, CCL's egc runs every 
:                 time 1 or 2 MB have been allocated, and GC time 
:                 depends (mostly) on how much non-garbage 
:                 survives.
: 12:28 < _schulte_> gbyers: alright thanks, I'll look for 
:                    reducing gc frequency in the manual
: 12:28 < _schulte_> oh, that makes sense then, since I'm 
:                    generating lots of large long-lived objects
: 12:29 < _schulte_> are there ways to declare objects as 
:                    long-lived, or possibly a without-gc macro?
: 12:31 < gbyers> (EGC NIL) will turn off the EGC, and 
:                 (SET-LISP-GC-THRESHOLD N) controls how often 
:                 full GC happens,  If you're creating many GB of 
:                 long-lived objects, then the GC will spend a lot 
:                 of time finding that there isn't much garbage.
: 12:31 < _schulte_> gbyers: thanks, I'll let-bind that while I 
:                    build up the pop and see if it helps
: 12:31  * _schulte_ is reading the gc chapter of the manual now
: 12:41 < gbyers> I don't remember whether it's documented, but 
:                 (GC-VERBOSE T) will print messages whenever the 
:                 GC runs (to C's stderr; if you use SLIME, that 
:                 stream may be hard to find ...) I suspect that 
:                 you'll see that the GC is running very often and 
:                 that it isn't freeing much.
#+end_quote

*** dynamic extent
If problems persists, look into dynamic extents for large short-lives
software objects.

#+begin_src lisp
  (let ((x (list 1 2 3)))
    (declare (dynamic-extent x))
    #| ... |#)
#+end_src

*** sbcl
#+begin_quote
I would suggest that your first stop should be the unglamorous ROOM
and its more exotic cousin

  (sb-vm::memory-usage :print-spaces t :print-summary nil)

to figure out just what kind of objects you are leaking. If the answer
is "instances", then

  (sb-vm:instance-usage :dynamic :top-n 100)

will tell you what kind of instances.

...which will make tracking down the actual leak that much easier.
#+end_quote

*** analysis                                                         :ATTACH:
    :PROPERTIES:
    :Attachments: beginning.types end.types
    :ID:       a6f9dac5-5d20-4d33-b96b-c14b6e2f70c1
    :END:
#+begin_src sh
    join <(sort /tmp/beginning.types ) <(sort /tmp/end.types ) \
        |awk '{print ($4-$2), $1}'|sort -rn|head -20
#+end_src

#+RESULTS:
| 1204160 | SB-IMPL::STRING-OUTPUT-STREAM             |
|  546880 | SB-FORMAT::FORMAT-DIRECTIVE               |
|  453760 | PATHNAME                                  |
|  207936 | SB-SYS:FD-STREAM                          |
|   89088 | SB-IMPL::STRING-INPUT-STREAM              |
|   61600 | SB-ALIEN-INTERNALS:ALIEN-VALUE            |
|   18880 | ASM-PERF                                  |
|   13632 | RESTART                                   |
|    6816 | SIMPLE-ERROR                              |
|    3072 | SB-DI::COMPILED-CODE-LOCATION             |
|    2560 | SB-DI::COMPILED-FRAME                     |
|    1344 | SB-PCL::FAST-METHOD-CALL                  |
|    1280 | SB-DI::BOGUS-DEBUG-FUN                    |
|    1008 | SB-C::COMPILED-DEBUG-FUN                  |
|     768 | SB-PCL::SLOT-INFO                         |
|     720 | SB-PCL::CACHE                             |
|     512 | SB-MOP:STANDARD-EFFECTIVE-SLOT-DEFINITION |
|     384 | SB-PCL::WRAPPER                           |
|     224 | SB-PCL::CACHING                           |
|     160 | SB-C::DEBUG-SOURCE                        |

*** h264 analysis
**** breakdown of total space
#+begin_src sh
  instances(){
      cat etc/data/h264-memory/$1  \
          | sed -n '/Breakdown for dynamic space:/,/space total./p' \
          | grep -v "Breakdown for dynamic space" \
          | grep -v "space total." \
          | sed 's/^ *//;s/,//g;s/bytes for \+[0-9]\+ //;s/ objects.//' \
          | awk '{print $2, $1}' \
          | sort; }
  
  join <(instances 0.txt) <(instances 14506.txt) \
      |awk '{print ($2-$4), $1}'|sort -rn|head
#+end_src

#+RESULTS:
| 430292496 | cons                          |
|  70620400 | simple-character-string       |
|  25039664 | instance                      |
|  18791088 | code                          |
|  14332816 | simple-vector                 |
|   3639552 | symbol                        |
|   3160016 | simple-array-unsigned-byte-64 |
|   1842688 | simple-base-string            |
|   1217472 | closure                       |
|   1206144 | simple-bit-vector             |

**** dynamic types
#+begin_src sh
  instances(){
      cat etc/data/h264-memory/$1  \
          | sed -n '/Top 200 dynamic/,$p' \
          | grep -v "Dynamic instance total" \
          | grep -v "Other types" \
          | sed 's/^ *//;s/: / /;s/ bytes,//;s/ objects//' \
          | sort; }
  
  join <(instances 0.txt) <(instances 14506.txt) \
      |awk '{print ($4-$2), $1}'|sort -rn|head
#+end_src

#+RESULTS:
| 240 | SB-C::FILE-INFO    |
| 224 | TWO-WAY-STREAM     |
| 192 | SB-C::SOURCE-INFO  |
|  64 | SB-C::NLX-INFO     |
|  61 | SB-THREAD:MUTEX    |
|  50 | SB-C::REF          |
|  48 | SB-C::IR2-NLX-INFO |
|  44 | SB-C::VOP          |
|  41 | SB-C::LVAR         |
|  35 | SB-C::CTRAN        |

** DONE Probably CCL needs to use sh-runner as well
: 2013.06.14.02.29.41: checkpoint after 2304 fitness evaluations
: 
: > Error: The value 0 is not of the expected type LIST.
: > While executing: CCL::LIST-DELETE-VERY-SIMPLE, in process Monitor thread for external process (/bin/sh -c g++  -o /tmp/NILF88j6u /tmp/NILxsCkcK.s -lpthread)(4607).
: 
: 
: ;;;
: ;;; #<PROCESS Monitor thread for external process (/bin/sh -c g++  -o /tmp/NILF88j6u /tmp/NILxsCkcK.s -lpthread)(4607) [Active] #x30205085D54D> requires access to Shared Terminal Input
: ;;; Type (:y 4607) to yield control to this thread.
: ;;;
: Unhandled exception 11 at 0x41cd90, context->regs at #x7f5fdd3915c8
: Exception occurred while executing foreign code
:  at set_n_bits + 112
: received signal 11; faulting address: 0x307e402c1000
: invalid permissions for mapped object
: ? for help
: [31935] Clozure CL kernel debugger: 

** DONE SB-INT:BUG
This was caused by running the room function, should no longer be a
problem.

Caused by =room= and either =sb-ext:dynamic-space-size= or
=sb-vm::DYNAMIC-USAGE= and either =sb-vm::memory-usage= or
=sb-vm:instance-usage=.

: debugger invoked on a SB-INT:BUG in thread
: #<THREAD RUNNING {1007754DD3}>:
:     failed AVER:
:       (OR (EQL (ROOM-INFO-LENGTH INFO) (1+ #)) (FLOATP OBJ)
:           (SIMPLE-ARRAY-NIL-P OBJ))
:   This is probably a bug in SBCL itself. (Alternatively, SBCL might have been
:   corrupted by bad user code, e.g. by an undefined Lisp operation like
:   (FMAKUNBOUND 'COMPILE), or by stray pointers from alien code or from unsafe
:   Lisp code; or there might be a bug in the OS or hardware that SBCL is running
:   on.) If it seems to be a bug in SBCL itself, the maintainers would like to
:   know about it. Bug reports are welcome on the SBCL mailing lists, which you
:   can find at <http://sbcl.sourceforge.net/>.
: 

: debugger invoked on a SB-INT:BUG in thread
: #<THREAD RUNNING {100A5A6473}>:
:     failed AVER: (< I 2)
:   This is probably a bug in SBCL itself. (Alternatively, SBCL might have been
:   corrupted by bad user code, e.g. by an undefined Lisp operation like
:   (FMAKUNBOUND 'COMPILE), or by stray pointers from alien code or from unsafe
:   Lisp code; or there might be a bug in the OS or hardware that SBCL is running
:   on.) If it seems to be a bug in SBCL itself, the maintainers would like to
:   know about it. Bug reports are welcome on the SBCL mailing lists, which you
:   can find at <http://sbcl.sourceforge.net/>.

With a handler case printing out the errors
: 2013.06.09.23.55.43: track-memory error: #<SB-INT:BUG "~@<failed AVER: ~2I~_~A~:>" {101A9E7843}>

: 2013.06.09.23.42.54: track-memory error: #<TYPE-ERROR expected-type: INTEGER
:                                  datum: #<invalid object #x3200000039>>

** DONE Some multi-proc multi-threaded errors
Wrapped the socket communication functions in error handlers.
: debugger invoked on a POLL-ERROR in thread
: #<THREAD RUNNING {10462AA273}>:
:   Error caught while polling file descriptor 12: Unknown error
: 2013.06.07.15.34.19: checkpoint after 60672 fitness evaluations

** DONE new code errors
Reverted use of =delete= in the eviction function.

: debugger invoked on a SB-KERNEL:INDEX-TOO-LARGE-ERROR in thread
: #<THREAD RUNNING {1045C77673}>:
:   The index 512 is too large.

: debugger invoked on a SB-KERNEL:INDEX-TOO-LARGE-ERROR in thread
: #<THREAD RUNNING {1045C754A3}>:
:   The index 511 is too large.

: debugger invoked on a SB-KERNEL:INDEX-TOO-LARGE-ERROR in thread
: #<THREAD RUNNING {103AE21713}>:  
:   The index 511 is too large.

: debugger invoked on a SIMPLE-ERROR in thread
: #<THREAD RUNNING {1045C779B3}>:
:   There is no applicable method for the generic function
:     #<STANDARD-GENERIC-FUNCTION FITNESS (1)>
:   when called with arguments
:     (NIL).

: debugger invoked on a SB-KERNEL:BOUNDING-INDICES-BAD-ERROR in thread
: #<THREAD RUNNING {10C7778993}>:
:   The bounding indices 0 and 513 are bad for a sequence of length 512.
: See also:
:   The ANSI Standard, Glossary entry for "bounding index designator"
:   The ANSI Standard, writeup for Issue SUBSEQ-OUT-OF-BOUNDS:IS-AN-ERROR

